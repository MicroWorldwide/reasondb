[{"name":"ReasonDB","description":"<p>ReasonDB is a multi-model datastorage API that can sit on-top of almost any key-value store. It supports <a href='#/reasondb/tutorials/indexedKeyValue'>indexed key-value storage</a> (similar to localStorage), <a href='#/reasondb/tutorials/graph'>graph storage</a> (similar to GunDB), and its own <a href='#/reasondb/tutorials/SQLlike'>SQL like statements</a>.</p><p>Available across all these approaches is a <a href='#/reasondb/tutorials/joqular'>pattern matching language</a> similar to but more extensive than that provided by MongoDB, <a href='#/reasondb/tutorials/types'>extended type storage</a> (Infinity, NaN, ...), <a href='#/reasondb/tutorials/fulltext'>full text indexing</a>, and multi-source <a href='#/reasondb/tutorials/conflictresolution'>conflict resolution</a>.</p><p>ReasonDB is available via <a href='https://github.com/anywhichway/reasondb'>GitHub</a> and <a href='https://www.npmjs.com/package/reasondb'>NPM</a> under an MIT license.<p>","path":"/reasondb","text":"","wordCount":0,"type":"TOC"},{"name":"Introduction","path":"/reasondb/introduction","text":"When released in October of 2016, ReasonDB was the first 100% native JavaScript automatically synchronizing object database with a SQL like syntax and swapable persistence engines for the browser or NodeJS. It also supported replacement of it underlying storage engine, full text indexing and search, JSON projections, pattern based queries using JOQULAR, streaming analytics, and 20 built-in predicates (including soundex and RegExp matching).\nNow, ReasonDB v1.x.x-b (currently in beta) also supports document and graph based storage and querying, functional queries, asynchronous cursors, 32 built-in predicates, fully indexed Dates, joins, multi-source conflict resolution, automatic data expiration, object validation and property aliasing, compuation, and defaults using an enhanced version of JOQULAR. All of this can be done on top of almost any key value store including localStorage and Redis.\nReasonDB does not require that the class of objects stored be a subclass of any other class, nor does it require objects provide a special calling interface. ReasonDB is probably more compatible with existing object models than any other JSON database. All objects inserted to the database can be activated so that they automatically save when changed or more controlled procedural and functional approaches can be used.\nReasonDB is available via GitHub and NPM under an MIT license.","wordCount":202,"type":"Content"},{"name":"Whats new ?","description":"recent announcements, news, latest and greatest","path":"/reasondb/whatsNew","text":"2019-01-01 To start off the new year, the AnyWhichWay database, which started as a separate project, has been merged with ReasonDB. Although this has resulted in the loss of functionality in some areas (e.g. selective indexing, and changes to the JOQULAR API, automated replicant synchronization), it has also added substiantial functionality including more predicates for JOQULAR, SQL like multi-class joins, direct API support for key/value and graph queries, enhanced automatic versioning and data conflict resolution, and cursors with all the power of arrays. And, it has dramatically simplfied the process of adding storage drivers for almost any key/value store.","wordCount":99,"type":"Content"},{"name":"Guides & Tutorials","description":"<p>The JOQULAR and Cursor tutotrials should be read before trying to use ReasonDB.</p>","path":"/reasondb/tutorials","text":"","wordCount":0,"type":"TOC"},{"name":"JOQULAR Pattern Matching","description":"MongoDB like JavaScript Query Language Representation","path":"/reasondb/tutorials/joqular","text":"JOQULAR provides a simple declaritive way to match and validate JSON objects during query processes. It is based heavily on the MongoDB pattern matching approach but adds support for inline tests, more built-in types, wild card and RegExp key matching, and simple custom extension. JOQULAR can also be used to support aliasing, the provision of default or computed values and object validation.\nAs will be seen in the examples below, a JOQULAR pattern is just a JavaScript object. In fact, all JavaScript objects are valid JOQULAR patterns with limited functionality, i.e. they will only match other JavaScript objects with identical data values in their leaf properties. In the context of ReasonDB, this means that a class instance not created as a result of a database query (and hence lacking an # id metadata property) can be used to retrieve similar objects from the database.\nJOQULAR provides 58 built-in predicates, almost infinite possibilities with inline tests and regular expressions. The ReasonDB implementation can be extended with new $ predicates in as little as one line of code.\nThe predicates can be broken down into a number of categories including comparisons like $lt, set and array operations like $includes, type tests like $isSSN, text search tests, and logical operators like $and. You can also use wild cards and RegExp property matching, inline tests and custom predicates. Every predicate can be used for both matching and validating objects.\nThe basic use of JOQULAR is best shown with an example. The pattern {age:{$gte: 21}} will match {name: \"joe\", age: 22} and {name: \"mary\", age: 21} but not {name: \"mark\", age:19}.\nNesting and logical operators are supported. The pattern {age: {$gte: 21}, address:{city: {$eq: \"Seattle\", $or: {$eq: \"Tacoma\"}}} will match {name: \"mary\", age: 21, address:{city: \"Seattle\", zipcode:\"98101\"}}} and {name: \"lauren\", age: 25, address:{city: \"Tacoma\"}}}\nIn some cases, predicates can take multiple arguments. When this happens, an array should be used to express the arguments. See $between and $matches for examples.\n&nbsp;\nComparison Operators\n$lt - Mathematical or string less than, e.g. {age: {$lt: 21}}.\n$lte - Mathematical or string less than or equal, e.g. {age: {$lte: 21}}.\n$eq - Primitive value soft equality, e.g. {age: {$eq: 21}} will match both {age: 21} and {age: \"21\"}.\n$eeq - Primitive value strict equality, e.g. {age: {$eq: 21}} will match {age: 21} and not {age: \"21\"}.\n$neq - Primitive value soft inequality.\n$neeq - Primitive value strict inequality.\n$gte - Mathematical or string greater than or equal, e.g. {age: {$gte: 21}}.\n$gt -  Mathematical or string greater than, e.g. {age: {$gt: 21}}.\n$matches - Applies a regular expression match. If an array argument is used, then the first argument is the regular expression and the second is the desired flags. If a string is passed instead of a regular expression, it will be converted into a regular expression, e.g. {name: {$match: [/jo*/,\"i\"]}} will match {name: \"jo\"} and {name: \"Joe\"}.\n&nbsp;\nSet and Array Operators\n$between - Tests if a value is between the provided numeric or string values. To make the test inclusive, pass true as the final value in the array of arguments, e.g. {age: {$between: [5,10]}} and {age: {$between: [5,10,true]}} will both match {age: 6} but only the second will match {age: 5}.\n$outside - Tests if a value is outside the provided numeric or string values, e.g. {age: {$outside: [5,10]}} will match {age: 11}.\n$in - Tests if the value is in the provided array, e.g. {age: {$in: [5,6]}} will match {age: 5} and {age: 6}.\n$nin - Tests if the value is not in the provided array, e.g. {age: {$nin: [5,6]}} will match {age: 4} but not {age: 6}.\n$includes - Assumes the target value is an array and checks to see if it includes the provided value, e.g. {favoriteNumbers: {$includes: 7}} matches {favoriteNumbers: [7,13]}.\n$excludes - Assumes the target value is an array and checks to see if it excludes the provided value, e.g. {favoriteNumbers: {$excludes: 8}} matches {favoriteNumbers: [7,13]}.\n$intersects - Assumes the target value is an array and checks to see if it intersects the provided value, e.g. {favoriteNumbers: {$intersects: [7,14]}} matches {favoriteNumbers: [7,13]}.\n$disjoint - Assumes the target value is an array and checks to see if it is disjoint with the provided value, e.g. {favoriteNumbers: {$disjoint: [3,14]}} matches {favoriteNumbers: [7,13]}.\n&nbsp;\nType Tests\n$typeof - Performs a test to see if the value is a boolean, number, object, or string, e.g. {id: {$typeof: \"string\"}}.\n$instanceof - Takes either a constructor or a string name of a constructor registered with ReasonDB and ensures the candiate object satisfies instanceof, e.g. {address: {$instanceof: \"Object\"}} will match {name: \"joe\", address: {city: \"Seattle\", state: \"WA\"}}\nUnary Type Tests\nIn some cases a test does not take an argument, i.e. it is not comparing the value to something else, it is just verifying it meets certain criteria. By convention these unary tests take null as their object value, e.g.\n`javascript\n{favoriteNumbers: [1,7]}\n`\nwill satisfy\n`javascript\n{favoriteNumbers: {$isArray: null}}\n`\nFoundational Unary Type Tests\nThe foundational tests are useful across many applications.\n$isArray - Examines internals of ReasonDB indexes to determine if the property value is an array.\n$isEven - Returns true if the value is a number and even.\n$isNaN - Returns true if the value is not a number or is the value NaN.\n$isOdd - Returns true if the value is a number and odd.\nExtended Unary Type Tests\nThe extened tests are more business oriented and application specific.\n$isCreditCard - Uses the Luhn algorithm to verify a number is a credit card number.\n$isEmail - Uses a regular expression to verify a value is a valid e-mail address. E-mail addresses are remarkably hard to validate. This covers most use cases.\n$isIPAddress - Returns true if the string is a dot delimited IP address.\n$isSSN - Returns true if the string is a dash delimited US social security number.\n&nbsp;\nText Search Tests\n$echoes - Uses a soundex algorithm, e.g. {name: {$echoes \"jo\"}} will match {name: \"joe\"}.\n$search - Looks to see if the search argument is contained in the property value using both stems and trigrams, e.g. {description: {$search: \"cars\"}} will match {description: \"This car is a 1960 Corvair convertible.\"} because \"car\" is a stem of \"cars\". Leverages full text indexes if available.\n&nbsp;\nLogical Operators\n$and - Puts multiple constraints on a property value, e.g {age: {$and: {$gte: 5, $lte: 10}}}.\n$not - Negates constraints on a property value, e.g {age: {$not: {$and: {$gte: 5, $lte: 10}}}}.\n$or - Puts an or constraint on a property value, e.g. {age: {$or: {$gte: 5, $lte: 10}}}. If you need to use the same predicate twice, then nest $or, e.g. {age: {$eq: 20, {$or: {$eq: 40}}}.\n$xor - Puts an xor constraint on a property value.\n&nbsp;\nWild Card & RegExp Property Names\nTo wild card a key use the the special key name $_. The below will match any object with any property that contains a value that looks like a social security number.\n`javascript\n{$_: {$isSSN: null}}\n`\nTo use a regular expression, just provide a key name that looks like a regular expression. Either of the below will match any objects with a property that ends in \"name\" and has a string value.\n`javascript\n{\"/.*name/\":{$typeof: \"string\"}}\n`\n`\n{[/.*name/]:{$typeof: \"string\"}} // use shorthand key initialization to ensure a valid RegExp.\n`\n&nbsp;\nInline Tests\nInline tests are invoked with the $ operator. They take a single argument, the value of the property being tested for the current object being considered as a match.\n`javascript\n{name: {$:value => value.length>=2}}\n`\n&nbsp;\nCustom Predicates\nAlmost all built-in predicates are defined the same way you define a predicate. Just create a function with the name you want prefixed by a $. The first argument will always be the value of the property on the object being tested and the second will be the argument to the predicate. If the predicate takes multiple arguments, they will also be present.\nPredicates may be of type async and/or return Promises. If they do, ReasonDB will await their resolution.\nBelow is the definition of $eq.\n`javascript\nfunction $eq(a,b) {\n\treturn a == b;\n}\n`\nTo add predicates to ReasonDB, just pass them in as an keyed object value for the property predicates on the options object when creating a database instance, e.g. new ReasonDB({predicates:{$eq}}).\nPredicates that are not defined this way rely on internals of ReasonDB that may change over time and how to create them is not the subject of further documentation.\nValidation\n$valid is itself a predicate and has available to it all other predicates. The below trivial case will always return matching objects:\n`javascript\n{name:{$typeof:\"string\",$valid:{$typeof: \"string\"}}}\n`\nHowever, in this case an error will be thrown:\n`javascript\n{name:{$typeof:\"string\",$valid:{$typeof: \"number\"}}}\n`\nOf course, one would never need to write the code above since the match ensured the type was a string. It is more likely code will be written to do something like the below that will throw a ConstraintViolationError with the message name failed validation $typeof for .\n`javascript\n{name:{$typeof:\"string\",$valid:{$: (value) => value.length>0}}}\n`\nTo trap the errors, provide an error handler that takes the error, the value being checked, the property the value was pulled from, and the object on which the property resides as arguments.\n`javascript\n{name:{\n\t$typeof:\"string\",\n\t$valid:{$: (value) => value.length>0, onError:(error,value,propertyName,containingObject) => {... do something ...;}}\n\t}}\n`\nYou can also provide a function as the value for $valid. The function takes the property value, the property name, and the containing object as arguments. In the case below the propertyName will be address and the containingObject will at a minimum have a name property with a string value and most likely an address property, although it could be undefined ... part of the reason for the validation!\n`javascript\n{name:{$typeof:\"string\"},address:{$valid:(theAddress,propertyName,containingObject) => { ... do something ... }}}\n`\nNote, custom validators must handle their own errors.\n&nbsp;\nAliasing, Defaults, and Computation\nFor the most part, ReasonDB uses JOQULAR for pattern matching and selection against indexes and entire objects are returned. However, the lanuage has been designed to support querying and extraction from single JSON objects. To add power when used in this context additional capabilities like column aliasing, default values, and computation are supported.\nAliasing\nThe below results in an object of the form {Age: } rather than {age:}.\n`javascript\n{age: {$:value => value >= 21, $as: \"Age\"}}\n`\nComputation\nProperties that don't exist on match result objects can be computed using $compute with a function that takes the current object and current key as arguments.\n`javascript\n{$instanceof: Person, {access: {$compute: (thisArg,key) => thisArg.age >= 21 ?  \"allowed\" ? \"denied\"; }}}\n`\nwill have thisArg bound to a Person and key bound to \"access\". It will result in\n`javascript\n{name: \"joe\",age: 27,access:\"allowed\"}\n`\nwhen matched against\n`javascript\nnew Person({name:\"joe\",age:27})\n`\nDefaults\nDefaults are computed after $compute in case the function associated with $compute returns null or undefined.\nDefaults can be raw values:\n`javascript\n{access: {$default: \"denied\"}}\n`\nOr, they can be functions that return values, similar to $compute, except that they don't take any arguments.\n`javascript\n{random: {$default: () => Math.random()}}\n`","wordCount":1703,"type":"Content"},{"name":"Cursors","description":"How query cursors work","path":"/reasondb/tutorials/cursors","text":"ReasonDB cursors are very powerful. They are enhanced JavaScript generator iterables so that they behave much like arrays except their methods are asynchronous, i.e. they support every, find, findIndex, forEach, includes, indexOf, keys, lastIndexOf, map, reduce, reverse, sort, slice, some, and values and can take asynchronous functions as arguments. You can even use array offsets, e.g. myCursor[0], if you first call withMemory().\nReasonDB cursors also support the statistical methods random and sample.\nIf the array like function called does not require accessing all items in the cursor, then results are effectively streamed one at a time. This works across client-server boundaries.\nAssume the this data is in the database:\n`javascript\n{userId: 1, name: \"joe\", age:26}\n{userId: 2, name: \"mary\", age:27}\n{userId: 3, name: \"jack\", age: 28}\n`\nThen you can do the following:\n`javascript\n\t// get users with ids greater than zero\n\tlet cursor = db.match({userId:{$gt: 0}});\n\t// you can use a regular for loop\n\tfor await(const item of cursor) {\n\t\tconsole.log(item);\n\t}\n\t// and reset the cursor to use it again\n\tcursor.reset();\n\t// and use arraylike functions that return Promises\n\t// they also provide the same argument signature as their Array counterparts\n\tcursor.forEach((object,index,generator) => console.log(object,index))\n\t .then(count => console.log(\"count\",count));\n\tcursor.reset();\n\t// arraylike functions can also be awaited\n\tif(await cursor.some(object => object.name===\"mary\")) {\n\t\tconsole.log(\"some object has the name mary\")\n\t}\n\t// you can chain directly to a cursor\n\tdb.match({userId:{$gt: 0}})\n\t\t.forEach((object,index,generator) => console.log(object,index))\n\t \t.then(count => console.log(\"count\",count));\n\tcursor.reset();\n\t// you can give the cursor memory so it is index accessable\n\t// Note: this does increase RAM usage\n\tcursor = cursor.withMemory({seek:true});\n\t// the first time an index is accessed, it must be awaited\n\tconsole.log(await cursor[1]);\n\t// when using arraylike functions, no reset is required if withMemory has been called\n\tcursor.forEach((object,index,generator) => console.log(object,index))\n\t .then(count => console.log(\"count\",count));\n\t// since forEach above accesses every array element, await is not needed below\n\tconsole.log(cursor[2]);\n\t// although awaiting will not hurt\n\tconsole.log(await cursor[2]);\n\t// arraylike functions can even call other async functions\n\tif(await cursor.every(async (object) => object.name!=null )) {\n\t\tconsole.log(\"every object has a name\")\n\t}\n\t// you can await cursor commands\n\tif(await cursor.some(object => object.name===\"mary\")) {\n\t\tconsole.log(\"some object has the name mary\")\n\t}\n\t// cursor support radom selection\n\tawait sample = cursor.random(2);\n\tconsole.log(sample); // will be an array with 2 elements\n\t// you can sample based on numeric properties\n\t// use a margin of error of 50% at a confidence interval of .999\n\tawait sample = cursor.sample({me:.5,ci:999,key:\"age\"});\n\tconsole.log(sample); // will be an array with 2 elements\n`","wordCount":351,"type":"Content"},{"name":"Indexed Key-Value Storage","description":"How to use indexed key-value storage","path":"/reasondb/tutorials/indexedKeyValue","text":"ReasonDB supports key value storage using an asynchronus API similar to the Storage API. The available methods include:\n1) setItem(key,value) - adds any type of value and associates it with a key.\n2) putItem(object[,force,options]) - insert the object into the database using the provided options. Uses the # property as the key. Objects inserted into the database are indexed so that they can be retrieved quickly using JOQULAR based matching against the indexes.\n3) getItem(key) - retrieves the value associated with the key\n4) match(pattern) - returns an cursor for all values in the database that match the provided JOQULAR pattern.\n5) removeItem(key||object) - removes item associated with the key, or the object based on its unique identifier #.\n6) clear() - Removes all keys and values from the database.\nkey(number) is not supported because the asynchronous nature of ReasonDB can't gurantee the sequential order in which keys get returned.\nFor more detail see the full [key-value API documentation]/#/reasondb/api/keyvalue).\nExample\n`javascript\n`","wordCount":151,"type":"Content"},{"name":"Graph Storage","description":"How to use graph storage","path":"/reasondb/tutorials/graph","text":"The graph database syntax supported by ReasonDB is similar to that supported by Gun. The basic commands for data insertion and retrieval are: get(path), value(val), delete(), remove(). There are also more advanced functions put(value), add(value), merge(value), patch(object). See the API documentation for full details.\nThe graph data model also supports triggers, once(function), on(triggers), off(triggers).\nGraph data models are very powerul, in fact the indexes of ReasonDB are just graphs as explained at the end of this article.\nAdding and Retrieving Data\nThe simplest way to think of a graph database is like a file system, each value is stored at a unique path. With ReasonDB, the paths even look like file paths. You can set a value by accessing a path and providing the value to the .value function. You can get a value by simply not providing a value to the .value function.\n`javascript\nawait db.get(\"person/joe/age\").value(27);\nconst age = db.get(\"/person/joe/age\").value(); // age will be 27\n`\nYou can also put values at multiple levels in the graph, not just leaves, e.g.\n`javascript\nawait db.get(\"a\").value(\"Value at a\");\nawait db.get(\"a/b\").value(\"Value at b\");\n`\nAnd, you can provide the path in multiple parts:\n`javascript\nawait db.get(\"a\").get(\"b\").value(\"Value at b\");\n`\nPath Expressions\nThe paths support an expression language that can include typical comparison operators like >,>=, value.length>2. You can also navigate up the graph by using ..`.\n`javacript\ndb.get(\"person/(id) => id.length  console.log(await age.value()));\n`\nThe path expression above is testing the path component and returning all edges with id lengths less than 3 to a cursor, if you want to test the value, then use a colon. The code for each of the below will return undefined unless the value stored on a/b is \"Value at b\".\n`javascript\nconst bvalue = await db.get(\"a/b:(value) => value === \"Value at b\").value();\n`\n`javascript\nconst bvalue = await db.get(\"a/b:$eq(\"Value at b)\").value();\n`\nDeleting Data\nTo delete data, just access the edge and call .delete(). Note, this deletes the value on the path, not the path itself.\n`javascript\nawait db.get(\"person/joe\").value(\"Joe is cool\");\nawait db.get(\"person/joe/age\").value(27);\nawait db.get(\"person/joe/age\").delete();\nconst age = db.get(\"person/joe/age\").value(); // age will be undefined\n`\nRemoving Paths\nTo remove an edge and all child paths, access the edge and call .remove().\n`javascript\nawait db.get(\"person/joe\").value(\"Joe is cool\");\nawait db.get(\"person/joe/age\").value(27);\nawait db.get(\"person/joe/eyeColor\").value(\"blue\");\nawait db.get(\"person/joe\").delete(); // delete the value on the edge\nconst comment = await db.get(\"person/joe\").value(); // comment will be undefined\nlet age = db.get(\"person/joe/age\").value(); // age will be 27\nawait db.get(\"person/joe\").remove(); // actually remove the edge\nage = db.get(\"person/joe/age\").value(); // age will be undefined\n`\n&nbsp;\nTriggers\nTriggers are added to graph nodes with the on(triggers) function. The triggers argument is an object that can have any of the following keys: get, new, change, delete, extend. These keys contain functions as values with the signatures defined below. The this context of the function will be the edge being impacted, so make sure you don't use arrow functions if you need access to the edge.\nIn all cases the functions can be asynchronous and Promises will be awaited. If you want to run something without waiting, then wrap the function with .async(function callback). This will automatically allow default behavior to continue while also producing a side-effect like logging.\nget(any currentValue) - Fires whenever .value() is called on a node. It takes one argument, the value about to be returned. It can replace currentValue with any value it desires to be returned to the calling application. The security model of ReasonDB will use this capability to return undefined when access to a value is not permitted.\n`javascript\nawait db.get(\"secret\")\n\t.value(\"you will never be able to use value() to see this text\")\n\t.on({get:(value)=>undefined})\n`\nnew(any newValue) - Fires whenever .value(value) is called and the existing value on the edge is undefined. It can replace newValue with any value it desires to be used instead.\n`javascript\nawait db.get(\"nothing\")\n\t.on({new: (value) => undefined});\nawait db.get(\"nothing\")\n\t.value(\"something\");\nconst value = db.get(\"nothing\").value(); // value = undefined\n`\nchange(any newValue,any oldValue) - Fires whenever .value(value) is called and the existing value does not match the new value. It is also called after .delete() and newValue will equal undefined. It can replace newValue with any value it desires to be used instead. The security model of ReasonDB uses this to prevent changes to the database.\n`javascript\nawait db.get(\"readonly\")\n\t.value(\"I can't be changed\")\n\t.on({change: (newValue,oldValue) => oldValue}); // always return oldValue\nawait db.get(\"readonly\")\n\t.value(\"I have been changed\");\nconst value = await db.get(\"readonly\")\n\t.value(); // value = \"I can't be changed\"\n`\ndelete() - Fires whenever .delete() is called. If it returns undefined the deletion will be aborted.\n`javascript\n`\nextend(Edge childEdge) - Fires whenever a child edge is added to an existing edge. Regardless of return value, processing continues.\n`javascript\ndb.get(\"/\").on({extend:function(childEdge) { ... do something ...; }}).\n`\nremove(Edge childEdge) - Fires whenever a child edge is removed from an edge. If it returns anything other than the new childEdge, removing the edge is aborted.\n`javascript\ndb.get(\"/\").on({extend:function(childEdge) { ... do something ...; return childEdge; }}).\n`\nYou can chain calls, e.g.\n`javascript\ndb.get(\"/\").on({extend:function(childEdge) { ... do something ...; return newEdge; }})\n  .get(\"a\").on({new:function(newValue) { ... do something ...; return newValue; }});\n`\nPersisting Triggers\nTriggers are automatically persisted and so long as they do not contain closure references will operate when restored. If you need to use triggers that use closures then you must do two things:\n1) Ensure you start your database with a cache that can keep the triggers in memory.\n2) Ensure you start your database with the option saveTriggers set to false.\n&nbsp;\nAutomatically Graphing Objects For Indexing\nUnless a graph data model parrallels the business domain being modeled, many people find the mapping of objects to graphs tedious and subject to error because there are many ways to choose path names. To help overcome this obstacle, ReasonDB provides the .putItem command. Just give it a JSON object and the graph will be created automatically. The graph created can acutally serve as an index for searching on objects.\n`javascript\nawait db.putItem({name:\"joe\",age:27});\nawait db.putItem({name:\"mary\",age:27});\n`\nWill first add unique ids to the objects, e.g. {name:\"joe\",age:27,\"#\":\"Object@a67fhtkquiryxst\"} and {name:\"mary\",age:27,\"#\":\"Object@a68fhtsquirxsy\"}. Then the following paths will be createded:\n`\nObject/name/\"joe\"/Object@a67fhtkquiryxst\nObject/name/\"mary\"/Object@a68fhtsquirxsy\nObject/age/27/Object@a67fhtkquiryxst\nObject/age/27/Object@a68fhtsquirxsy\n`\nNote above that the path actually has \"joe\" and \"mary\" as embedded strings. This is an internal optimization for ReasonDB indexes.\nYou can now query the graph for all 27 year olds as follows:\n`javascript\nconst people = db.get(\"Object/age/==27/*\");\npeople.forEach(person => console.log(await person.value()));\n`\nWhich will print:\n`javacript\n{\"name\":\"joe\",\"age:27\",\"#\":\"Object@a67fhtkquiryxst\"}\n{\"name\":\"mary\",\"age:27\",\"#\":\"Object@a68fhtsquirxsy\"}\n`\nThe .value function is \"smart\" and knows that if a value represents a unique id, it should return the object, not the id.\nYou can even use custom classes:\n`javascript\nclass Person {\n\tconstructor(config) {\n\t\tObject.assign(this,config);\n\t}\n}\nconst p1 = new Person({\"name\":\"joe\",\"age:27\"}),\n\tp2 = new Person({\"name\":\"mary\",\"age:27\"});\ndb.putItem(p1);\ndb.putItem(p2);\n`\nwill result in the following paths being created:\n`\nPerson/name/\"joe\"/Person@a67fhtkquiryxst\nPerson/name/\"mary\"/Person@a68fhtsquirxsy\nPerson/age/27/Person@a67fhtkquiryxst\nPerson/age/27/Person@a68fhtsquirxsy\n`","wordCount":998,"type":"Content"},{"name":"SQL Like Statements","description":"How to use SQL like statements","path":"/reasondb/tutorials/SQLlike","text":"ReasonDB supports a set of commands that use a SQL like naming convention and processing approach. These include delete; insert;select with aliasing, projections, computed columns, where clauses, joins, groupBy, and orderBy, and update.\nEach statement initiator is available on the ReasonDB instance of your application. Once a terminating clause os a statement is called a Promise is returned. Or, in the case of select a cursor and once the cursor completes processing a Promise.\nThe current version of ReasonDB is schemaless and you just use regular classes constructors in place of tables. If you don't want to use custom classes, just use Object.\nThe where clauses associated with delete, select, and update use JOQULAR for pattern matching.\nA series of examples are provided below and further details on the specifics of each command are provides below. Also see the  API documentation .\ndelete\n`javascript\n// delete all Persons\ndb.delete().from(Person)\n\t.then((count) => ... do something ... });\n`\n`javascript\n// delete all Persons with age 58\ndb.delete().from(Person)\n\t.where({age:{$eq:58}})\n\t.then((count) => ... do something ... });\n`\ninsert\n`javascript\ndb.insert({name:\"juliana\",age:58},{name:joe,age:56})\n\t.into(Person)\n\t.then((count) => ... do something ...});\n`\nselect\nBefore using select ensure you understand cursors.\n`javascript\ndb.select()\n\t.from(Person)\n\t.forEach({person} => ... do something ...)\n\t.then((count) => ... do something ...});\n`\n`javascript\ndb.select()\n\t.from(Person)\n\t.where({Person:{name:\"juliana\",age:{$eq:58}}})\n\t.forEach({person} => ... do something ...)\n\t.then((count) => ... do something ...});\n`\n`javascript\ndb.select()\n\t.from({p:Person})\n\t.where({p:{name:\"juliana\",age:{$eq:58}}})\n\t.forEach({person} => ... do something ...)\n\t.then((count) => ... do something ...});\n`\n`javascript\ndb.select({p:\n\t{\n\t\tname:\"Name\", // aliased using string\n\t\tage:{as:\"Age\"}, // aliased using configuration objects\n\t\tgender:{as:\"Gender\",default:\"TBD\"}, // aliased with default value\n\t\thalfAge:{default:({Age}) => Age/2}, // computed value using aliased column\n\t\ttwiceAge:{default:({p}) => p.age*2}}, // computed value using aliased object\n\t\tavgAvg: {$: {avg:\"age\"}}, // avg of all ages for all results, min, avg, max are supported\n\t\trunningAvgAge:{$: {avg:\"age\",running:true}} // running avg at the point found in cursor processing\n\t})\n\t.from({p:Person})\n\t.forEach({person} => ... do something ...)\n\t.then((count) => ... do something ...});\n`\n`javascript\ndb.select()\n\t.from({p1:Person,p2:Person})\n\t.where({p1:{name:{$eq:\"juliana\"}},p2:{name:{$eq:{p1:{name:\"$\"}}}}})\n\t.every(({p1,p2}) => p1.name===p2.name && p1.name===\"juliana\")\n\t.then(() => .. do something ...);\n`\n`javascript\ndb.select()\n\t.from({p1:Person})\n\t.join({p2:Person})\n\t.on(({p1,p2}) => p1.name===\"juliana\" && p1.name===p2.name ? {p1,p2} : false)\n\t.every(({p1,p2}) => p1.name===p2.name && p1.name===\"juliana\")\n\t.then(() => .. do something ...);\n`\n`javascript\ndb.select()\n\t.from({p1:db.select().from(Person)})\n\t.join({p2:db.select().from(Person)})\n\t.on(({p1,p2}) => p1.name===\"juliana\" && p1.name===p2.name ? {p1,p2} : false)\n\t.every(({p1,p2}) => p1.name===p2.name && p1.name===\"juliana\")\n\t.then(() => .. do something ...);\n`\n`javascript\n db.select()\n \t.from({p1:Person})\n \t.natural({p2:db.select().from(Person)})\n\t.some(({p1,p2}) => ... test something ...)\n\t.then(() => .. do something ...);\n`\n`javascript\ndb.select()\n\t.from({p1:Person})\n\t.cross(db.select().from({p2:Person}))\n\t.forEach({p1,p2} => ... do something ...)\n\t.then((count) => ... do something ...);\n`\n`javascript\ndb.select().from(Person)\n\t.join(db.select().from(Person))\n\t.on((left,right) => left.name===\"juliana\" ? {left,right} : false);\n\t.every(item => ... test something ...)\n\t.then(() => .. do something ...);\n`\n`javascript\ndb.select()\n\t.from(Person)\n\t.join(db.select()\t.from(Person))\n\t.on((left,right) => right.name===\"juliana\" ? {left,right} : false)\n\t.every(item => ... test something ...)\n\t.then(() => .. do something ...);\n`\n`javascript\ndb.select()\n\t.from(Person)\n\t.join(db.select()\t.from(Person))\n\t.on((left,right) => {left,right})\n\t.some(item => ... test something ...)\n\t.forEach(item => ... do something ...);\n`\n`javascript\ndb.update(Person)\n\t.set({age:60))\n\t.where({name:59)\n\t.then((count) => ... do something ... });","wordCount":381,"type":"Content"},{"name":"Database start-up and storage engines","description":"How to start-up a database and use any key value storage engine","path":"/reasondb/tutorials/startup","text":"This article covers basic database startup, configuring a custom store, and start-up options.\n&nbsp;\nBasic Database Startup\nStarting up a database is simple!\n`javascript\nimport {ReasonDB} from \"../index.js\";\nconst db = ReasonDB.db();\n`\nThe above will create an in memory database since their is no official industry standard persistent store that exists for both the browser and NodeJs. However, using a persistent store is easy:\n`javascript\nimport {ReasonDB} from \"../index.js\";\nconst db = ReasonDB.db({storage:localStorage});\n`\nYou can now add data using the key/value, graph, or SQL like API.\n`javascript\ndb.setItem(\"counter\",1);\n`\nor\n`javascript\ndb.get(\"counter\").value(1);\n`\nor\n`javascript\ndb.insert({counter: 1}).into(Object);\n`\n&nbsp;\nConfiguring A Custom Store\nSo long as your storage engine supports setItem, getItem, removeItem, and clear you will have all the power of ReasonDB. That's right you will even have a graph database and SQL like querying. Internally, ReasonDB maps everything to a key value store for maximum portability.\nSince Redis is a very popular key-value store, an example with Redis is provided below.\n`javascript\nimport {ReasonDB} from \"../index.js\";\nconst\tRedis = require('ioredis');\nclass RedisStorage extends Redis {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t}\n\tasync clear() {\n\t\treturn this.flushdb();\n\t}\n\tasync getItem(key) {\n\t\treturn this.get(key);\n\t}\n\tasync removeItem(key) {\n\t\treturn this.del(key);\n\t}\n\tasync setItem(key,value) {\n\t\treturn this.set(key,value);\n\t}\n}\nconst db = ReasonDB.db({storage:new RedisStorage()});\n`\n&nbsp;\nStart-up Options\nA database can be started with a number of options in addition to storage:\npredicates - An object the keys on which are predicate names with functions implementing the predicates as their values. See the JOQULAR article for the built-in predicates.\ncache - An object supporting the methods getItem(string key), setItem(string key,any value), and removeItem(string key). You can also pass the value true, in which case a built-in LFRU (Least Frequentyly Used) Cache cache will be provided.\nthis.options = options = Object.assign({},options);\n\t\tif(!options.authenticate) options.authenticate = () => true;\n\t\tif(!options.storage) options.storage = MEMORYSTORAGE;\n\t\tthis.schema = Object.assign({},SCHEMA,options.schema);\n\t\tthis.predicates = Object.assign({},predicates,options.predicates);\n\t\tthis.cache = new LFRUStorage();\n\t\tthis.Edge = (config={},force) => {\n\t\t\treturn new Edge(this,config,force);\n\t\t}\n\t\tif(options.onready) this.onready = options.onready;\n\t\tthis.remote = options.remote||[];\n\t\tthis.initialized = new Promise(async resolve => {\n\t\t\tconst storage = options.storage;\n\t\t\tif(options.clear) await this.clear();\n\t\t\tif(options.authenticate) await options.authenticate.call(this);\n\t\t\tconst root = await storage.getItem(\"/\");\n\t\t\tif(!root) await storage.setItem(\"/\",JSON.stringify(this.Edge()));\n\t\t\tawait this.secure();\n\t\t\tthis.expire();\n\t\t\tif(options.listen) this.listen(options.listen,options);\n\t\t\tresolve();\n\t\t\tif(this.onready) this.onready.call(this);\n\t\t});","wordCount":290,"type":"Content"},{"name":"Full text indexing","description":"Using stem and trigram based full text indexing","path":"/reasondb/tutorials/fulltext","text":"","wordCount":0,"type":"Content"},{"name":"Extended Type Storage & Indexing","description":"Types of data that can be stored and indexed","path":"/reasondb/tutorials/types","text":"In addition to standard JavaScript primitive data types, ReasonDB can store the values NaN, Infinity, and -Infinity.\nAll properties are indexed and unless an object is marked as atomic, nested objects are replaced with their index key @ during serialization. With the future introduction of schema, indexing will become optional.\nIn some cases, objects can be restored directly from their key value. For example, Dates are not stored directly in the database, they are stored as keys of the form Date@. This conserves RAM and also avoids un-necessry disk access. However, it is generally transparent to the database developer due to the automatic serializing and de-serializing of data by ReasonDB.\nAdditional custom types can be created that leverage the above approach when minimal data is required to define an object, e.g. GeoPoint is currently under development. How to add these types of classes will be documented in a future release.\nReasonDB does not currently support fixed precision or big decimal math; hence, it should not be used for financial applications requiring substative accounting.","wordCount":169,"type":"Content"},{"name":"Browser vs NodeJS Use","description":"How to use in a browser or with NodeJS","path":"/reasondb/tutorials/browservsnode","text":"ReasonDB uses the JavaScript module format and is not currently transpiled due to issues with Babel traspilation of async generators.\nBrowser Use\nTo load ReasonDB apps in the browser, make the entire src tree of the installed package available for client use by copying it to your JavaScript directory. Copy index.js to reasondb.js in the root of your JavaScript directory. Then import reasondb.js in your app entry point file. Then load your entry point in an HTML file using the module flag.\n`html\n`\nSee example HTML files in the examples directory.\nTo run the test suite, just load /test/index.html.\nWe are working on a webpack build, but due to the advanced JavaScript features used by ReasonDB are having some issues.\nNode Use\nNodeJS currently requires that JavaScript modules be stored in and loaded from .mjs files. ReasonDB is almost 100% isomorphic (i.e. runs the same code on the server as in the client) and the default NodeJS approach breaks isomorphism. Fortunately, there is a great package called esm that effectively overcomes this issue. The esm package is installed as a dependency for ReasonDB. To run a ReasonDB NodeJS application use a command like this:\n`\nnode -r esm index.js\n`\nTo run the test suite use:\n`\nmocha -r esm index.js\n`","wordCount":197,"type":"Content"},{"name":"Conflict Resolution","description":"How conflict resolution works","path":"/reasondb/tutorials/conflictresolution","text":"In preparation for replicated storage, ReasonDB supports conflict resolution, i.e. when an attempt is made to replace one object in the database with another ReasonDB will arbitrate which is the best to use. To manage this process, ReasonDB maintains a \"soul\" for each object (this term is borrowed from GunDB). The soul is metadata that tracks the id, creation datetime, last update datetime, a version number, and whether the object is atomic, i.e. nested objects are an intrisic part of the primary object or joined objects. Below is a fragment of code that illustrates the algorithm used:\n`\n// if the time on the updated objects is the same as the time on the current version\n// and the version of the update is the same as the current version\n// and the update was originally created the same time as the current version\n// and the updated object is identical to the current version of the object\n// then just return, no update is necessary\nif(utime===ctime && usoul.version===csoul.version\n   && usoul.createdAt===csoul.createdAt && deepEqual(updated,current)) {\n\treturn;\n}\n// if the time of the update is in the future\n// then schedule it for the future to avoid real time skew or time spoofing\nif(utime - now > 0) {\n\tsetTimeout(() => this.putItem(updated),utime - now);\n\treturn;\n}\n// if the time on the updated object is before the time on the current version\n// then just return, no update necessary because current version is more recent\nif(utimectime) {\n\tusoul.version = Math.max(usoul.version,csoul.version);\n\treturn updated;\n}\n// if version and update time are the same (very rare)\nif(usoul.version===csoul.version && utime===ctime) {\n\t// if update is more recently created\n\t// return the object to be used as the update\n\tif(ucreated>ccreated) {\n\t\treturn updated;\n\t}\n\t// if current is more recently created\n\t// then just return, no update necessary\n\tif(ccreated>ucreated) {\n\t\treturn; // throw away\n\t}\n\t// if key is lexically greater (arbitrary but consistent approach)\n\t// then update the version of the updated soul to the maximum version and use it\n\tif(usoul[\"#\"]>=csoul[\"#\"]) {\n\t\tusoul.version = Math.max(usoul.version,csoul.version);\n\t\treturn updated; // use the update (abitrary but consistent approach)\n\t}\n}\n// otherwise something very odd has happened\n// e.g. different version numbers but same update or create times\n// ignore the update\n`","wordCount":331,"type":"Content"},{"name":"API Documentation","description":"APIs","path":"/reasondb/api","text":"","wordCount":0,"type":"TOC"},{"name":"API Introduction","description":"how to read the API documentation","path":"/reasondb/api/introduction","text":"The API is broken down by its major components. For each component the functions are listed in alphabetical order. For each function there is:\n1) A description.\n2) A call signature syntax based loosely on TypeScript.\n3) Documentation for each parameter.\n4) Return value type documentation.\n5) Documentation for directly thrown errors. Note, exceptions are not yet fully documented and the lack of documentation does not mean an exception can't be thrown.\n6) An example","wordCount":69,"type":"Content"},{"name":"Key-Value API","description":"Comprehensive documentation for the key-value API","path":"/reasondb/api/keyvalue","text":"The key-value API has the same surface similar to the JavaScript Storage API, except it adds putItem(object object) and match(object JOQULARpattern), the methods are asynchronous, the methods take some additional optional arguments, length and key() are not available.","wordCount":38,"type":"Content"},{"name":"clear","description":"emptying the database","path":"/reasondb/api/keyvalue/clear","text":"clear\nEmpties the database.\nSyntax\nclear()\nParameters\nNone\nExceptions\nExample","wordCount":3,"type":"Content"},{"name":"getItem","description":"retrieving data by key","path":"/reasondb/api/keyvalue/getitem","text":"getItem\nWhen passed a key name, will return that key's value.\nSyntax\nany result = await db.getItem(string key)\nParameters\nstring key - A string containing the name of the key you want to retrieve the value of.\nReturn Value\nThe value of the item associated with key. If there is no item, returns undefined.\nExceptions\n&nbsp;\nExample","wordCount":47,"type":"Content"},{"name":"match","description":"retrieving data by matching","path":"/reasondb/api/keyvalue/match","text":"match\nWhen passed a JOQULAR pattern, will return a cursor for all matching objects in the database.\nSyntax\nCursor result = await db.match(Object pattern||string path)\nParameters\nObject pattern - A pattern in JOQULAR syntax.\nstring path - A string containing the name of the key you want to retrieve the value of.\nReturn Value\nA Cursor to iterate over all the values if any.\nExceptions\nExample","wordCount":56,"type":"Content"},{"name":"putItem","description":"adding indexed objects","path":"/reasondb/api/keyvalue/putitem","text":"putItem\nWhen passed an object, will insert the object into the database using the options provided, which default to those used for database start-up. A unique id and version number will be added to the metadata stored in the . property if one does not exist. The id will be accessable through either .[\"#\"] or [\"#\"]. If the object is already under versioning, its version will be incremented unless call options indicate otherwise.\nSyntax\nany result = await db.putItem(object[,force=false,options=this.options])\nParameters\nObject object - An object to insert.\nboolean force - If truthy, will force a save and index of the object without incrementing the version number and timestamps.\nObject options - See database startup.\nReturn Value\nThe return value is that of the underlying storage engine, typically undefined.\nExceptions\n&nbsp;\nExample","wordCount":119,"type":"Content"},{"name":"removeItem","description":"retrieving data by key","path":"/reasondb/api/keyvalue/removeitem","text":"removeItem\nWhen passed a key name, will remove that key from the database if it exists. If there is no item associated with the given key, this method will do nothing.\nSyntax\nany result = await db.removeItem(string key||Object object)\nParameters\nstring key - A string containing the name of the key for which you want to remove the value.\nObject object - An object with a unique id in the property #. This is then used to remove the item by making a subcall to removeItem.\nReturn Value\nThe return value is that of the underlying storage engine, typically undefined.\nExceptions\nExample","wordCount":92,"type":"Content"},{"name":"setItem","description":"adding data ascociated with a key","path":"/reasondb/api/keyvalue/setitem","text":"setItem\nAdds any type of value and associates it with a key. If the value is an object and the database option indexAllObjects is truthy, then the object will be added to indexes.\nSyntax\nany result = await db.setItem(string key,any value)\nParameters\nstring key - A string containing the name of the key you want to create/update.\nany value - The value you want to give the key you are creating/updating. It can be of any type.\nReturn Value\nThe return value is that of the underlying storage engine, typically undefined.\nExceptions\nExample","wordCount":83,"type":"Content"},{"name":"Graph API","description":"Comprehensive documentation for the graph API","path":"/reasondb/api/graph","text":"","wordCount":0,"type":"Content"},{"name":"SQL Like API","description":"Comprehensive documentation for the SQL like API","path":"/reasondb/api/sqllike","text":"The SQL like API for ReasonDB has four entry points that do the same things as their SQL counterparts:","wordCount":19,"type":"Content"},{"name":"Delete","description":"deleting objects","path":"/reasondb/api/sqllike/delete","text":"delete\nDeletes an object from a database.\nSyntax\n`javascript\nPromise delete()\n\t.from(function sourceSpec)\n\t.where(object JOQULARPattern)\n\t.then(function(count) ...)\n`\nParameters\nfunction sourceSpec - The class of the object to delete.\nobject JOQULARPattern - A JOQULAR pattern object used to look-up the instances to delete.\nReturn Value\nA Promise with a then function taking one argument, the count of objects deleted.\nExceptions\nAny JOQULARTypeError thrown during the validation of the JOQULARPattern.\nExample","wordCount":54,"type":"Content"},{"name":"Insert","description":"inserting objects","path":"/reasondb/api/sqllike/insert","text":"insert\nInserts an object into a database.\nSyntax\n`javascript\nPromise insert(object object[,...])\n\t.into(function sourceSpec)\n\t.then(function(count) ...)\n`\nParameters\nobject object... - The objects to insert. Objects will automatically be coerced into instances of class. Inserting an object with a # id that already exists in the database throws a error.`\nReturn Value\nA Promise with a then function taking one argument, the count of objects inserted.\nExceptions\nA ConstraintViolationError is thrown when an attempt is made to insert an object with with a # id that matches an id that already exists in the database. This is effectively the same as a primary key violation in SQL.\nExample","wordCount":94,"type":"Content"},{"name":"Insert","description":"retrieving objects","path":"/reasondb/api/sqllike/select","text":"select\nSelects objects from a database.\nSyntax\n`javascript\nPromise select([object propertySpecs[,...]])\n\t.from(function sourceSpec||object sourceSpec[,...]||Cursor sourceSpec)\n\t[.cross(object sourceSpec||Cursor sourceSpec)||natural(object sourceSpec||Cursor sourceSpec)||.where(object JOQULARPattern)]\n\t[.]\n\t.\n\t.then(function(count) ...)\n`\nParameters\nobject propertySpecs... - This is an optional argument. The propertySpecs... will automatically be combined into one propertySpec. If not provided, it behaves the same way as a SQL select *. If provided, then an aliasing object must be used as for sourceSpec. The surface of a propertySpec has this surface:\n`\n{:\n\t{key: string asName || object {[as: string asName\n\t\t\t\t\t\t\t\t\t\t [,default: any value||function f\n\t\t\t\t\t\t\t\t\t\t  [,compute: function f\n\t\t\t\t\t\t\t\t\t\t   [,$: : string propertyName]]]]}}}\n`\nfunction sourceSpec - The class of the object to look for.\nobject sourceSpec... - Aliased classes to join in the search for objects. The sourceSpec... will automatically be merges into one object. The surface of the sourceSpec has this surface:\n`\n{:function class[,: function class[,...]]}\n`\ncursor sourceSpec - The cursor returned by another select.\nobject JOQULARPattern - A JOQULAR pattern object used to look-up the instances.\n. - An optional component of a select that has this form:\n`\n.join(object sourceSpec||Cursor sourceSpec)\n\t[.on(function (object aliasedRecord) { return ... boolean test ...})]\n`\nReturn Value\nA Promise with a then function taking one argument, the count of objects inserted.\nExceptions\nAny JOQULARTypeError thrown during the validation of the JOQULARPattern.\nExample","wordCount":186,"type":"Content"},{"name":"Update","description":"updating objects","path":"/reasondb/api/sqllike/update","text":"","wordCount":0,"type":"Content"},{"name":"Helpful Links","description":"Additional reading, links to other database APIs","path":"/reasondb/links","text":"Links\nGunDB\nMongoDB","wordCount":1,"type":"Content"}]