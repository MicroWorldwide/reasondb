[{"name":"ReasonDB","description":"<p>ReasonDB is a multi-model datastorage API that can sit on-top of almost any key/value store. It supports <a href='#/reasondb/tutorials/indexedKeyValue'>indexed key/value storage</a> (similar to localStorage), <a href='/#/reasondb/tutorials/graph'>graph storage</a> (similar to GunDB), and its own <a href='/#/reasondb/tutorials/SQLlike'>SQL like statements</a>.</p><p>Available across all these approaches is a <a href='/#/reasondb/tutorials/joqular'>pattern matching language</a> similar to but more extensive than that provided by MongoDB, <a href='/#/reasondb/tutorials/types'>extended type storage</a> (Infinity, NaN, ...), <a href='/#/reasondb/tutorials/fulltext'>full text indexing</a>, and multi-source <a href='/#/reasondb/tutorials/conflictresolution'>conflict resolution</a>.</p>","path":"/reasondb","text":"","wordCount":0,"type":"TOC"},{"name":"Introduction","description":"detailed introduction","path":"/reasondb/introduction","text":"When first released in October of 2016, ReasonDB was the first 100% native JavaScript automatically synchronizing object database with a SQL like syntax and swapable persistence engines for the browser or NodeJS.\nReasonDB also supports document and graph based storage and querying, full text indexing and search, JSON projections, pattern based and functional queries, asynchronous cursors, streaming analytics, 32 built-in predicates (including soundex and RegExp matching), in-line fat arrow predicates, predicate extensibility, indexable computed values, fully indexed Dates, joins, nested matching, statistical computations or sampling, and automatic data expiration.\nReasonDB does not require that the class of objects stored be a subclass of any other class, nor does it require objects provide a special calling interface. ReasonDB is probably more compatible with existing object models than any other JSON database. All objects inserted to the database can be activated so that they automatically save or more controlled procedural and functional approaches can be used.","wordCount":152,"type":"Content"},{"name":"Whats new ?","description":"recent announcements, news, latest and greatest","path":"/reasondb/whatsNew","text":"2019-01-01 To start off the new year, the AnyWhichWay database, which started as a separate project, has been merged with ReasonDB. Although this has resulted in the loss of functionality in some areas (e.g. selective indexing, and changes to the JOQULAR API, automated replicant synchronization), it has also added substiantial functionality including more predicates for JOQULAR, SQL like multi-class joins, direct API support for key/value and graph queries, enhanced automatic versioning and data conflict resolution, and cursors with all the power of arrays. And, it has dramatically simplfied the process of adding storage drivers for almost any key/value store.","wordCount":99,"type":"Content"},{"name":"Guides & Tutorials","description":"<p>The first three guides marked with an exclamation should be read before trying to use ReasonDB.</p>","path":"/reasondb/tutorials","text":"","wordCount":0,"type":"TOC"},{"name":"Browser vs NodeJS Use","description":"How to use in a browser or with NodeJS","path":"/reasondb/tutorials/browservsnode","text":"ReasonDB uses the JavaScript module format and is not currently transpiled due to issues with Babel traspilation of async generators.\nBrowser Use\nTo load ReasonDB apps in the browser, make the entire src tree of the installed package available for client use by copying it to your JavaScript directory. Copy index.js to reasondb.js in the root of your JavaScript directory. Then import reasondb.js in your app entry point file. Then load your entry point in an HTML file using the module flag.\n`html\n`\nSee example HTML files in the examples directory.\nTo run the test suite, just load /test/index.html.\nWe are working on a webpack build, but due to the advanced JavaScript features used by ReasonDB are having some issues.\nNode Use\nNodeJS currently requires that JavaScript modules be stored in and loaded from .mjs files. ReasonDB is almost 100% isomorphic (i.e. runs the same code on the server as in the client) and the default NodeJS approach breaks isomorphism. Fortunately, there is a great package called esm that effectively overcomes this issue. The esm package is installed as a dependency for ReasonDB. To run a ReasonDB NodeJS application use a command like this:\n`\nnode -r esm index.js\n`\nTo run the test suite use:\n`\nmocha -r esm index.js\n`","wordCount":197,"type":"Content"},{"name":"JOQULAR Pattern Matching","description":"MongoDB like JavaScript Query Language Representation","path":"/reasondb/tutorials/joqular","text":"JOQULAR provides a simple declaritive way to match JSON objects during query processes. It is based heavily on the MongoDB pattern matching approach but adds support for inline tests and simple extension.\nIn the context of ReasonDB, JOQULAR provides built-in 56 predicates, almost infinite possibilities with inline tests, and and can be extended with new $ predicates in as little as one line of code.\nThe predicates can be broken down into a number of categories including comparisons like $lt, set and array operations like $includes, type tests like $isSSN, text search tests, and logical operators like $and. You can also use inline tests and custom predicates.\nThe basic use of JOQULAR is best shown with an example. The pattern {age:{$gte: 21}} will match {name: \"joe\", age: 22} and {name: \"mary\", age: 21} but not {name: \"mark\", age:19}.\nIn some cases, predicates can take multiple arguments. When this happens, an array shoul dbe used to express the arguments. See $between and $matches for an example.\n&nbsp;\nComparison Operators\n$lt - Mathematical or string less than, e.g. {age: {$lt: 21}}.\n$lte - Mathematical or string less than or equal, e.g. {age: {$lte: 21}}.\n$eq - Primitive value soft equality, e.g. {age: {$eq: 21}} will match both {age: 21} and {age: \"21\"}.\n$eeq - Primitive value strict equality, e.g. {age: {$eq: 21}} will match {age: 21} and not {age: \"21\"}.\n$neq - Primitive value soft inequality.\n$neeq - Primitive value strict inequality.\n$gte - Mathematical or string greater than or equal, e.g. {age: {$gte: 21}}.\n$gt -  Mathematical or string greater than, e.g. {age: {$gt: 21}}.\n$matches - Applies a regular expression match. If an array argument is used, then the first argument is the regular expression and the second is the desired flags. If a string is passed instead of a regular expression, it will be converted into a regular expression, e.g. {name: {$match: [/jo*/,\"i\"]}} will match {name: \"jo\"} and {name: \"Joe\"}.\n&nbsp;\nSet and Array Operators\n$between - Tests if a value is between the provided numeric or string values. To make the test inclusive, pass true as the final value in the array of arguments, e.g. {age: {$between: [5,10]}} and {age: {$between: [5,10,true]}} will both match {age: 6} but only the second will match {age: 5}.\n$outside - Tests if a value is outside the provided numeric or string values, e.g. {age: {$outside: [5,10]}} will match {age: 11}.\n$in - Tests if the value is in the provided array, e.g. {age: {$in: [5,6]}} will match {age: 5} and {age: 6}.\n$nin - Tests if the value is not in the provided array, e.g. {age: {$nin: [5,6]}} will match {age: 4} but not {age: 6}.\n$includes - Assumes the target value is an array and checks to see if it includes the provided value, e.g. {favoriteNumbers: {$includes: 7}} matches {favoriteNumbers: [7,13]}.\n$excludes - Assumes the target value is an array and checks to see if it excludes the provided value, e.g. {favoriteNumbers: {$excludes: 8}} matches {favoriteNumbers: [7,13]}.\n$intersects - Assumes the target value is an array and checks to see if it intersects the provided value, e.g. {favoriteNumbers: {$intersects: [7,14]}} matches {favoriteNumbers: [7,13]}.\n$disjoint - Assumes the target value is an array and checks to see if it is disjoint with the provided value, e.g. {favoriteNumbers: {$disjoint: [3,14]}} matches {favoriteNumbers: [7,13]}.\n&nbsp;\nType Tests\n$typeof -\n$instanceof - Takes either a constructor or a string name of a constructor registered with ReasonDB and ensures the candiate object satisfies instanceof, e.g. {address: {$instanceof: \"Object\"}} will match {name: \"joe\", address: {city: \"Seattle\", state: \"WA\"}}\n$isArray - Examines internals of ReasonDB indexes to determine if the property value is an array.\n$isCreditCard - Uses the Luhn algorithm to verify a number is a credit caard number.\n$isEmail - Uses a regular expression to verify a value is a valid e-mail address.\n$isEven - Returns true if the value is a number and even.\n$isIPAddress - Returns true if the string is a dot delimited IP address.\n$isNaN - Returns true if the value is not a number or is the value NaN.\n$isOdd - Returns true if the value is a number and odd.\n$isSSN - Returns true is the string is a dash delimited US social security number.\n&nbsp;\nText Search Tests\n$echoes - Uses a soundex algorithm, e.g. {name: {$echoes \"jo\"}} will match {name: \"joe\"}.\n$search - Looks to see if the search argument is contained in the property value using both stems and trigrams, e.g. {description: {$search: \"cars\"}} will match {description: \"This car is a 1960 Corvair convertible.\"} because \"car\" is a stem of \"cars\". Leverages full text indexes if available.\n&nbsp;\nLogical Operators\n$and - Puts multiple constraints on a property value, e.g {age: {$and: {$gte: 5, $lte: 10}}}.\n$not - Negates constraints on a property value, e.g {age: {$not: {$and: {$gte: 5, $lte: 10}}}}.\n$or - Puts an or constraint on a property value.\n$xor - Puts an xor constraint on a property value.\n&nbsp;\nInline Tests\nInline tests are invoked with the $ operator. They take a single argument, the value of the property being tested for the current object being considered as a match.\n`javascript\n{name: {$:value => value.length>=2}}\n`\n&nbsp;\nCustom Predicates\nAlmost all built-in predicates are defined the same way you define a predicate. Just create a function with the name you want prefixed by a $. The first argument will always be the value of the property on the object being tested and the second will be the argument to the predicate. If the predicate takes multiple arguments, they will also be present.\nPredicates may be of type async and/or return Promises. If they do, ReasonDB will await their resolution.\nBelow is the definition of $eq.\n`javascript\nfunction $eq(a,b) {\n\treturn a == b;\n}\n`\nTo add predicates to ReasonDB, just pass them in as an keyed object value for the property predicates on the options object when creating a database instance, e.g. new ReasonDB({predicates:{$eq}}).\nPredicates that are not defined this way rely on internals of ReasonDB that may change over time and how to create them is not the subject of further documentation.","wordCount":957,"type":"Content"},{"name":"Extended Type Storage & Indexing","description":"Types of data that can be stored and indexed","path":"/reasondb/tutorials/types","text":"In addition to standard JavaScript primitive data types, ReasonDB can store the values NaN, Infinity, and -Infinity.\nAll properties are indexed and unless an object is marked as atomic, nested objects are replaced with their index key @ during serialization. With the future introduction of schema, indexing will become optional.\nIn some cases, objects can be restored directly from their key value. For example, Dates are not stored directly in the database, they are stored as keys of the form Date@. This conserves RAM and also avoids un-necessry disk access. However, it is generally transparent to the database developer due to the automatic serializing and de-serializing of data by ReasonDB.\nAdditional custom types can be created that leverage the above approach when minimal data is required to define an object, e.g. GeoPoint is currently under development. How to add these types of classes will be documented in a future release.\nReasonDB does not currently support fixed precision or big decimal math; hence, it should not be used for financial applications requiring substative accounting.","wordCount":169,"type":"Content"},{"name":"Cursors","description":"How query cursors work","path":"/reasondb/tutorials/cursors","text":"ReasonDB cursors are very powerful. They are enhanced JavaScript generator iterables so that they behave much like arrays except their methods are asynchronous, i.e. they support every, find, findIndex, forEach, includes, indexOf, keys, lastIndexOf, map, reduce, reverse, sort, slice, some, and values and can take asynchronous functions as arguments. You can even use array offsets, e.g. myCursor[0], if you first call withMemory().\nReasonDB cursors also support the statistical methods random and sample.\nAssume the following data is in the database:\n`javascript\n{userId: 1, name: \"joe\", age:26}\n{userId: 2, name: \"mary\", age:27}\n{userId: 3, name: \"jack\", age: 28}\n`\nThen you can do the following:\n`javascript\n\tlet cursor = db.match({userId:{$gt: 0}});\n\t// you can use a regular for loop\n\tfor await(const item of cursor) {\n\t\tconsole.log(item);\n\t}\n\t// and reset the cursor to use it again\n\tcursor.reset();\n\tfor await(const item of cursor) {\n\t\tconsole.log(item);\n\t}\n\tcursor.reset();\n\t// you can give the cursor memory so it is index accessable\n\t// and tell it to collect statistics\n\t// Note: this does increase RAM usage\n\tcursor = cursor.withMemory({seek:true});\n\t//the first time an index is accessed, it must be awaited\n\tconsole.log(await cursor[1]);\n\t// when using arraylike functions, no reset is required if withMemory has been called\n\t// all arraylike functions return Promises\n\t// they also provide the same argument signature as their Array counterparts\n\tcursor.forEach((object,index,generator) => console.log(object,index))\n\t .then(count => console.log(\"count\",count));\n\t// arraylike functions can also be awaited\n\tif(await cursor.some(object => object.name===\"mary\")) {\n\t\tconsole.log(\"some object has the name mary\")\n\t}\n\t// arraylike functions can even call other async functions\n\tif(await cursor.every(async (object) => object.name!=null )) {\n\t\tconsole.log(\"every object has a name\")\n\t}\n\t//since forEach above accesses every array element, await is not needed below\n\tconsole.log(cursor[2]);\n\t//although awaiting will not hurt\n\tconsole.log(await cursor[2]);\n\t// randomly choose 2 of the results\n\tawait sample = cursor.random(2);\n\tconsole.log(sample); // will be an array with 2 elements\n\t// select a random sample based on age\n\t// use a margin of error of 50% at a confidence interval of .999\n\tawait sample = cursor.sample({me:.5,ci:999,key:\"age\"});\n\tconsole.log(sample); // will be an array with 2 elements\n`","wordCount":292,"type":"Content"},{"name":"Database start-up and storage engines","description":"How to start-up a database and use any key value storage engine","path":"/reasondb/tutorials/startup","text":"This article covers basic database startup, configuring a custom store, and start-up options.\n&nbsp;\nBasic Database Startup\nStarting up a database is simple!\n`javascript\nimport {ReasonDB} from \"../index.js\";\nconst db = ReasonDB.db();\n`\nThe above will create an in memory database since their is no official industry standard persistent store that exists for both the browser and NodeJs. However, using a persistent store is easy:\n`javascript\nimport {ReasonDB} from \"../index.js\";\nconst db = ReasonDB.db({storage:localStorage});\n`\n&nbsp;\nConfiguring A Custom Store\nSo long as your storage engine supports setItem, getItem, removeItem, and clear you will have all the power of ReasonDB. That's right you will even have a graph database and SQL like querying. Internally, ReasonDB maps everything to a key value store for maximum portability.\nSince Redis is a very popular key-value store, an example with Redis is provided below.\n`javascript\nimport {ReasonDB} from \"../index.js\";\nconst\tRedis = require('ioredis');\nclass RedisStorage extends Redis {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t}\n\tasync clear() {\n\t\treturn this.flushdb();\n\t}\n\tasync getItem(key) {\n\t\treturn this.get(key);\n\t}\n\tasync removeItem(key) {\n\t\treturn this.del(key);\n\t}\n\tasync setItem(key,value) {\n\t\treturn this.set(key,value);\n\t}\n}\nconst db = ReasonDB.db({storage:new RedisStorage()});\n`\n&nbsp;\nStart-up Options\nA database can be started with a number of options in addition to storage:\npredicates - An object the keys on which are predicate names with functions implementing the predicates as their values. See the JOQULAR article for the built-in predicates.\ncache - An object supporting the methods getItem(string key), setItem(string key,any value), and removeItem(string key). You can also pass the value true, in which case a built-in LFRU (Least Frequentyly Used) Cache cache will be provided.\nthis.options = options = Object.assign({},options);\n\t\tif(!options.authenticate) options.authenticate = () => true;\n\t\tif(!options.storage) options.storage = MEMORYSTORAGE;\n\t\tthis.schema = Object.assign({},SCHEMA,options.schema);\n\t\tthis.predicates = Object.assign({},predicates,options.predicates);\n\t\tthis.cache = new LFRUStorage();\n\t\tthis.Edge = (config={},force) => {\n\t\t\treturn new Edge(this,config,force);\n\t\t}\n\t\tif(options.onready) this.onready = options.onready;\n\t\tthis.remote = options.remote||[];\n\t\tthis.initialized = new Promise(async resolve => {\n\t\t\tconst storage = options.storage;\n\t\t\tif(options.clear) await this.clear();\n\t\t\tif(options.authenticate) await options.authenticate.call(this);\n\t\t\tconst root = await storage.getItem(\"/\");\n\t\t\tif(!root) await storage.setItem(\"/\",JSON.stringify(this.Edge()));\n\t\t\tawait this.secure();\n\t\t\tthis.expire();\n\t\t\tif(options.listen) this.listen(options.listen,options);\n\t\t\tresolve();\n\t\t\tif(this.onready) this.onready.call(this);\n\t\t});","wordCount":277,"type":"Content"},{"name":"Indexed Key/Value Storage","description":"How to use indexed key/value storage","path":"/reasondb/tutorials/indexedKeyValue","text":"ReasonDB supports key value storage using an asynchronus API similar to the Storage API. The available methods include:\n1) async setItem(key,value) - adds any type of value and associates it with a key.\n2) async putItem(object[,force,options]) - insert the object into the database using the provided options.\n3) async getItem(key) - retrieves the value associated with the key\n4) async* match(pattern) = returns an cursor for all values in the database that match the provided JOQULAR pattern.\n5) async removeItem(key||object||) - removes item associated with the key, or the object based on its unique identifier.\n6) async clear() = Removes all key and values from the database.\nkey(number) is not supported because the asynchronous nature of ReasonDB can't gurantee the sequential order in which keys get returned.\nObjects inserted into the database are optionally indexed so that they can be retrieved using\nExample\n`javascript\n`\n&nbsp;\nsetItem\nAdds any type of value and associates it with a key. If the value is an object and the database option indexAllObjects is truthy, then the object will be added to indexes.\nSyntax\nvar result = await db.setItem(key,value)\nParameters\nkey - A string containing the name of the key you want to create/update.\nvalue - The value you want to give the key you are creating/updating. It can be of any type.\nReturn Value\nThe return value is that of the underlying storage engine, typically undefined.\nExceptions\n&nbsp;\nputItem\nWhen passed an object, will insert the object into the database using the options provided, which default to those used for database start-up. A unique id and version number will be added to the metadata stored in the . property if one does not exist. The id will be accessable through either .[\"#\"] or [\"#\"]. If the object is already under versioning, its version will be incremented unless call options indicate otherwise.\nSyntax\nvar result = await db.putItem(object[,force=false,options=this.options])\nParameters\nobject - An object to insert.\nforce - If truthy, will force a save and index of the object without incrementing the version number and timestamps.\noptions - See database startup.\nReturn Value\nThe return value is that of the underlying storage engine, typically undefined.\nExceptions\n&nbsp;\ngetItem\nWhen passed a key name, will return that key's value.\nSyntax\nvar result = await db.getItem(key)\nParameters\nkey - A string containing the name of the key you want to retrieve the value of.\nReturn Value\nThe value of the item associated with key. If there is no item, returns undefined.\nExceptions\n&nbsp;\nmatch\nWhen passed a JOQULAR pattern, will return a cursor for all matching objects in the database.\nSyntax\nvar result = await db.match(pattern)\nParameters\nkey - A string containing the name of the key you want to retrieve the value of.\nReturn Value\nThe value of the item associated with key. If there is no item, returns undefined.\nExceptions\n&nbsp;\nremoveItem\nWhen passed a key name, will remove that key from the database if it exists. If there is no item associated with the given key, this method will do nothing.\nSyntax\nvar result = await db.removeItem(key||object)\nParameters\nkey - A string containing the name of the key for which you want to remove the value.\nobject - An object with a unique id in the property #.\nReturn Value\nThe return value is that of the underlying storage engine, typically undefined.\nExceptions","wordCount":494,"type":"Content"},{"name":"Graph Storage","description":"How to use graph storage","path":"/reasondb/tutorials/graph","text":"The graph database syntax supported by ReasonDB is similar to that supported by Gun. The basic commands for data insertion and retrieval are: get(path), value(val), delete(), remove(). There are also more advanced functions put(value), add(value), merge(value), patch(object). See the API documentation for full details.\nThe graph data model also supports triggers, once(function), on(triggers), off(triggers).\nGraph data models are very powerul, in fact the indexes of ReasonDB are just graphs as explained at the end of this article.\nAdding and Retrieving Data\nThe simplest way to think of a graph database is like a file system, each value is stored at a unique path. With ReasonDB, the paths even look like file paths. You can set a value by accessing a path and providing the value to the .value function. You can get a value by simply not providing a value to the .value function.\n`javascript\nawait db.get(\"person/joe/age\").value(27);\nconst age = db.get(\"/person/joe/age\").value(); // age will be 27\n`\nYou can also put values at multiple levels in the graph, not just leaves, e.g.\n`javascript\nawait db.get(\"a\").value(\"Value at a\");\nawait db.get(\"a/b\").value(\"Value at b\");\n`\nAnd, you can provide the path in multiple parts:\n`javascript\nawait db.get(\"a\").get(\"b\").value(\"Value at b\");\n`\nPath Expressions\nThe paths support an expression language that can include typical comparison operators like >,>=, value.length>2. You can also navigate up the graph by using ..`.\n`javacript\ndb.get(\"person/(id) => id.length  console.log(await age.value()));\n`\nThe path expression above is testing the path component and returning all edges with id lengths les than 3 to a cursor, if you want to test the value, then use a colon. The code for each of the below will return undefined unless the value stored on a/b is \"Value at b\".\n`javascript\nconst bvalue = await db.get(\"a/b:(value) => value === \"Value at b\").value();\n`\n`javascript\nconst bvalue = await db.get(\"a/b:$eq(\"Value at b)\").value();\n`\nDeleting Data\nTo delete data, just access the edge and call .delete().\n`javascript\nawait db.get(\"person/joe\").value(\"Joe is cool\");\nawait db.get(\"person/joe/age\").value(27);\nawait db.get(\"person/joe/age\").delete();\nconst age = db.get(\"person/joe/age\").value(); // age will be undefined\n`\nRemoving Paths\nTo remove an edge and all child paths, access the edge and call .remove().\n`javascript\nawait db.get(\"person/joe\").value(\"Joe is cool\");\nawait db.get(\"person/joe/age\").value(27);\nawait db.get(\"person/joe/eyeColor\").value(\"blue\");\nawait db.get(\"person/joe\").delete(); // delete the value on the edge\nconst comment = await db.get(\"person/joe\").value(); // comment will be undefined\nlet age = db.get(\"person/joe/age\").value(); // age will be 27\nawait db.get(\"person/joe\").remove(); // actually remove the edge\nage = db.get(\"person/joe/age\").value(); // age will be undefined\n`\n&nbsp;\nTriggers\nTriggers are added to graph nodes with the on(triggers) function. The triggers argument is an object that can have any of the following keys: get, new, change, delete, extend. These keys contain functions as values with the signatures defined below. The this context of the function will be the edge being impacted, so make sure you don't use arrow functions if you need access to the edge.\nIn all cases the functions can be asynchronous and Promises will be awaited. If you want to run something without waiting, then wrap the function with .async(function callback). This will automatically allow default behavior to continue while also producing a side-effect like logging.\nget(any currentValue) - Fires whenever .value() is called on a node. It takes one argument, the value about to be returned. It can replace currentValue with any value it desires to be returned to the calling application. The security model of ReasonDB will use this capability to return undefined when access to a value is not permitted.\n`javascript\nawait db.get(\"secret\")\n\t.value(\"you will never be able to use value() to see this text\")\n\t.on({get:(value)=>undefined})\n`\nnew(any newValue) - Fires whenever .value(value) is called and the existing value on the edge is undefined. It can replace newValue with any value it desires to be used instead.\n`javascript\nawait db.get(\"nothing\")\n\t.on({new: (value) => undefined});\nawait db.get(\"nothing\")\n\t.value(\"something\");\nconst value = db.get(\"nothing\").value(); // value = undefined\n`\nchange(any newValue,any oldValue) - Fires whenever .value(value) is called and the existing value does not match the new value. It is also called after .delete() and newValue will equal undefined. It can replace newValue with any value it desires to be used instead. The security model of ReasonDB uses this to prevent changes to the database.\n`javascript\nawait db.get(\"readonly\")\n\t.value(\"I can't be changed\")\n\t.on({change: (newValue,oldValue) => oldValue}); // always return oldValue\nawait db.get(\"readonly\")\n\t.value(\"I have been changed\");\nconst value = await db.get(\"readonly\")\n\t.value(); // value = \"I can't be changed\"\n`\ndelete() - Fires whenever .delete() is called. If it returns undefined the deletion will be aborted.\n`javascript\n`\nextend(Edge childEdge) - Fires whenever a child edge is added to an existing edge. Regardless of return value, processing continues.\n`javascript\ndb.get(\"/\").on({extend:function(childEdge) { ... do something ...; }}).\n`\nremove(Edge childEdge) - Fires whenever a child edge is removed from an edge. If it returns anything other than the new childEdge, removing the edge is aborted.\n`javascript\ndb.get(\"/\").on({extend:function(childEdge) { ... do something ...; return childEdge; }}).\n`\nYou can chain calls, e.g.\n`javascript\ndb.get(\"/\").on({extend:function(childEdge) { ... do something ...; return newEdge; }})\n  .get(\"a\").on({new:function(newValue) { ... do something ...; return newValue; }});\n`\nPersisting Triggers\nTriggers are automatically persisted and so long as they do not contain closure references will operate when restored. If you need to use triggers that use closures then you must do two things:\n1) Ensure you start your database with a cache that can keep the triggers in memory.\n2) Ensure you start your database with the option saveTriggers set to false.\n&nbsp;\nAutomatically Graphing Objects For Indexing\nUnless a graph data model parrallels the business domain being modeled, many people find the mapping of objects to graphs tedious and subject to error because there are many ways to choose path names. To help overcome this obstacle, ReasonDB provides the .putItem command. Just give it a JSON object and the graph will be created automatically. The graph created can acutally serve as an index for searching on objects.\n`javascript\nawait db.putItem({name:\"joe\",age:27});\nawait db.putItem({name:\"mary\",age:27});\n`\nWill first add unique ids to the objects, e.g. {name:\"joe\",age:27,\"#\":\"Object@a67fhtkquiryxst\"} and {name:\"mary\",age:27,\"#\":\"Object@a68fhtsquirxsy\"}. Then the following paths will be createded:\n`\nObject/name/\"joe\"/Object@a67fhtkquiryxst\nObject/name/\"mary\"/Object@a68fhtsquirxsy\nObject/age/27/Object@a67fhtkquiryxst\nObject/age/27/Object@a68fhtsquirxsy\n`\nNote above that the path actually has \"joe\" and \"mary\" as embedded strings. This is an internal optimization for ReasonDB indexes.\nYou can now query the graph for all 27 year olds as follows:\n`javascript\nconst people = db.get(\"Object/age/==27/*\");\npeople.forEach(person => console.log(await person.value()));\n`\nWhich will print:\n`javacript\n{\"name\":\"joe\",\"age:27\",\"#\":\"Object@a67fhtkquiryxst\"}\n{\"name\":\"mary\",\"age:27\",\"#\":\"Object@a68fhtsquirxsy\"}\n`\nThe .value function is \"smart\" and knows that if a value represents a unique id, it should return the object, not the id.\nYou can even use custom classes:\n`javascript\nclass Person {\n\tconstructor(config) {\n\t\tObject.assign(this,config);\n\t}\n}\nconst p1 = new Person({\"name\":\"joe\",\"age:27\"}),\n\tp2 = new Person({\"name\":\"mary\",\"age:27\"});\ndb.putItem(p1);\ndb.putItem(p2);\n`\nwill result in the following paths being created:\n`\nPerson/name/\"joe\"/Person@a67fhtkquiryxst\nPerson/name/\"mary\"/Person@a68fhtsquirxsy\nPerson/age/27/Person@a67fhtkquiryxst\nPerson/age/27/Person@a68fhtsquirxsy\n`","wordCount":986,"type":"Content"},{"name":"SQL Like Statements","description":"How to use SQL like statements","path":"/reasondb/tutorials/SQLlike","text":"ReasonDB supports a set of commands that use a SQL like naming convention and processing approach. These include delete; insert;select with aliasing, projections, computed columns, where clauses, joins, groupBy, and orderBy, and update.\nEach command is available on the ReasonDB instance of your application and after it has been created can be invoked with the exec() command which returns either a regular promise, or in the case of select a cursor.\nThe current version of ReasonDB is schemaless and you just use regular classes in place of tables. If you don't want to use custom classes, just use Object.\nThe where clauses associated with delete, select, and update use JOQULAR  for pattern matching.\ndelete\n`javascript\n// delete all Persons\ndb.delete().from(Person)\n\texec()\n\t.then((count) => ... do something ... });\n`\n`javascript\n// delete all Persons with age 58\ndb.delete().from(Person)\n\t.where({age:{$eq:58}})\n\texec()\n\t.then((count) => ... do something ... });\n`\ninsert\n`javascript\ndb.insert({name:\"juliana\",age:58},{name:joe,age:56})\n\t.into(Person)\n\t.exec()\n\t.then((count) => ... do something ...});\n`\nselect\nBefore using select ensure you understand cursors.\n`javascript\ndb.select()\n\t.from(Person)\n\t.exec()\n\t.forEach({person} => ... do something ...)\n\t.then((count) => ... do something ...});\n`\n`javascript\ndb.select()\n\t.from(Person)\n\t.where({Person:{name:\"juliana\",age:{$eq:58}}})\n\t.exec()\n\t.forEach({person} => ... do something ...)\n\t.then((count) => ... do something ...});\n`\n`javascript\ndb.select()\n\t.from({p:Person})\n\t.where({p:{name:\"juliana\",age:{$eq:58}}})\n\t.exec()\n\t.forEach({person} => ... do something ...)\n\t.then((count) => ... do something ...});\n`\n`javascript\ndb.select({p:\n\t{\n\t\tname:\"Name\", // aliased using string\n\t\tage:{as:\"Age\"}, // aliased using configuration objects\n\t\tgender:{as:\"Gender\",default:\"TBD\"}, // aliased with default value\n\t\thalfAge:{default:({Age}) => Age/2}, // computed value using aliased column\n\t\ttwiceAge:{default:({p}) => p.age*2}}, // computed value using aliased object\n\t\tavgAvg: {$: {avg:\"age\"}}, // avg of all ages for all results, min, avg, max are supported\n\t\trunningAvgAge:{$: {avg:\"age\",running:true}} // running avg at the point found in cursor processing\n\t})\n\t.from({p:Person})\n\t.exec()\n\t.forEach({person} => ... do something ...)\n\t.then((count) => ... do something ...});\n`\n`javascript\ndb.select()\n\t.from({p1:Person,p2:Person})\n\t.where({p1:{name:{$eq:\"juliana\"}},p2:{name:{$eq:{p1:{name:\"$\"}}}}})\n\t.every(({p1,p2}) => p1.name===p2.name && p1.name===\"juliana\")\n\t.then(() => .. do something ...);\n`\n`javascript\ndb.select()\n\t.from({p1:Person})\n\t.join({p2:Person})\n\t.on(({p1,p2}) => p1.name===\"juliana\" && p1.name===p2.name ? {p1,p2} : false)\n\t.every(({p1,p2}) => p1.name===p2.name && p1.name===\"juliana\")\n\t.then(() => .. do something ...);\n`\n`javascript\ndb.select()\n\t.from({p1:db.select().from(Person)})\n\t.join({p2:db.select().from(Person)})\n\t.on(({p1,p2}) => p1.name===\"juliana\" && p1.name===p2.name ? {p1,p2} : false)\n\t.every(({p1,p2}) => p1.name===p2.name && p1.name===\"juliana\")\n\t.exec()\n\t.then(() => .. do something ...);\n`\n`javascript\n db.select()\n \t.from({p1:Person})\n \t.natural()\n \t.join({p2:db.select().from(Person)})\n\t.some(({p1,p2}) => ... test something ...)\n\t.exec()\n\t.then(() => .. do something ...);\n`\n`javascript\ndb.select()\n\t.from({p1:Person})\n\t.cross(db.select().from({p2:Person}))\n\t.exec()\n\t.forEach({p1,p2} => ... do something ...)\n\t.then((count) => ... do something ...);\n`\n`javascript\ndb.select().from(Person)\n\t.join(db.select().from(Person))\n\t.on((left,right) => left.name===\"juliana\" ? {left,right} : false);\n\t.every(item => ... test something ...)\n\t.exec()\n\t.then(() => .. do something ...);\n`\n`javascript\ndb.select()\n\t.from(Person)\n\t.join(db.select()\t.from(Person))\n\t.on((left,right) => right.name===\"juliana\" ? {left,right} : false)\n\t.every(item => ... test something ...)\n\t.exec()\n\t.then(() => .. do something ...);\n`\n`javascript\ndb.select()\n\t.from(Person)\n\t.join(db.select()\t.from(Person))\n\t.on((left,right) => {left,right})\n\t.some(item => ... test something ...)\n\t.exec()\n\t.forEach(item => ... do something ...);\n`\n`javascript\ndb.update(Person)\n\t.set({age:60))\n\t.where({name:59)\n\t.exec()\n\t.then((count) => ... do something ... });","wordCount":354,"type":"Content"},{"name":"Full text indexing","description":"Using stem and trigram based full text indexing","path":"/reasondb/tutorials/fulltext","text":"","wordCount":0,"type":"Content"},{"name":"Conflict Resolution","description":"How conflict resolution works","path":"/reasondb/tutorials/conflictresolution","text":"In preparation for replicated storage, ReasonDB supports conflict resolution, i.e. when an attempt is made to replace one object in the database with another ReasonDB will arbitrate which is the best to use. To manage this process, ReasonDB maintains a \"soul\" for each object (this term is borrowed from GunDB). The soul is metadata that tracks the id, creation datetime, last update datetime, a version number, and whether the object is atomic, i.e. nested objects are an intrisic part of the primary object or joined objects. Below is a fragment of code that illustrates the algorithm used:\n`\n// if the time on the updated objects is the same as the time on the current version\n// and the version of the update is the same as the current version\n// and the update was originally created the same time as the current version\n// and the updated object is identical to the current version of the object\n// then just return, no update is necessary\nif(utime===ctime && usoul.version===csoul.version\n   && usoul.createdAt===csoul.createdAt && deepEqual(updated,current)) {\n\treturn;\n}\n// if the time of the update is in the future\n// then schedule it for the future to avoid real time skew or time spoofing\nif(utime - now > 0) {\n\tsetTimeout(() => this.putItem(updated),utime - now);\n\treturn;\n}\n// if the time on the updated object is before the time on the current version\n// then just return, no update necessary because current version is more recent\nif(utimectime) {\n\tusoul.version = Math.max(usoul.version,csoul.version);\n\treturn updated;\n}\n// if version and update time are the same (very rare)\nif(usoul.version===csoul.version && utime===ctime) {\n\t// if update is more recently created\n\t// return the object to be used as the update\n\tif(ucreated>ccreated) {\n\t\treturn updated;\n\t}\n\t// if current is more recently created\n\t// then just return, no update necessary\n\tif(ccreated>ucreated) {\n\t\treturn; // throw away\n\t}\n\t// if key is lexically greater (arbitrary but consistent approach)\n\t// then update the version of the updated soul to the maximum version and use it\n\tif(usoul[\"#\"]>=csoul[\"#\"]) {\n\t\tusoul.version = Math.max(usoul.version,csoul.version);\n\t\treturn updated; // use the update (abitrary but consistent approach)\n\t}\n}\n// otherwise something very odd has happened\n// e.g. different version numbers but same update or create times\n// ignore the update\n`","wordCount":331,"type":"Content"},{"name":"API Documentation","description":"APIs","path":"/reasondb/api","text":"","wordCount":0,"type":"TOC"},{"name":"API Introduction","description":"how to read the API documentation","path":"/reasondb/api/introduction","text":"","wordCount":0,"type":"Content"},{"name":"Helpful Links","description":"Additional reading, links to other database APIs","path":"/reasondb/links","text":"Links\nTBD","wordCount":1,"type":"Content"},{"name":"FAQs","description":"Frequently asked questions are covered here","path":"/reasondb/faq","text":"This content is refreshed as new features and functions are introduced, or existing functions evolve.  Check back often!","wordCount":18,"type":"Content"},{"name":"Our Roadmap","description":"Aligning our development plans with our stakeholders","path":"/reasondb/roadmap","text":"","wordCount":0,"type":"Content"}]