[{"name":"ReasonDB","description":"<p>ReasonDB is a multi-model datastorage API that can sit on-top of almost any key/value store. It supports <a href='#/reasondb/tutorials/indexedKeyValue'>indexed key/value storage</a> (similar to localStorage), <a href='/#/reasondb/tutorials/graph'>graph storage</a> (similar to GunDB), and its own <a href='/#/reasondb/tutorials/SQLlike'>SQL like statements</a>.</p><p>Available across all these approaches is a <a href='/#/reasondb/tutorials/joqular'>pattern matching language</a> similar to but more extensive than that provided by MongoDB, <a href='/#/reasondb/tutorials/types'>extended type storage</a> (Infinity, NaN, ...), <a href='/#/reasondb/tutorials/fulltext'>full text indexing</a>, and multi-source <a href='/#/reasondb/tutorials/conflictresolution'>conflict resolution</a>.</p>","path":"/reasondb","text":"","wordCount":0,"type":"TOC"},{"name":"Whats new ?","description":"recent announcements, news, latest and greatest","path":"/reasondb/whatsNew","text":"2019-01-01 To start off the new year, the AnyWhichWay database, which started as a separate project, has been merged with ReasonDB. Although this has resulted in the loss of functionality in some areas (e.g. selective indexing, and changes to the JOQULAR API), it has also added substiantial functionality including more predicates, multi-class joins, direct API support for key/value and graph queries, data conflict resolution, basic security, and cursors with all the power of arrays. And, it has dramatically simplfied the process of adding storage drivers for almost any key/value store.","wordCount":90,"type":"Content"},{"name":"Guides & Tutorials","description":"<p>Guides & Tutorials<p><p>The first three guides marked with an exclamation should be read before trying to use ReasonDB.</p>","path":"/reasondb/tutorials","text":"","wordCount":0,"type":"TOC"},{"name":"Browser vs NodeJS Use","description":"How to use in a browser or with NodeJS","path":"/reasondb/tutorials/browservsnode","text":"ReasonDB uses the JavaScript module format and is not currently transpiled due to issues with Babel traspilation of async generators.\nBrowser Use\nTo load ReasonDB apps in the browser, make the entire src tree of the installed package available plus index.js, then import index.js in your app entry point file. Then load your entry point in an HTML file using the module flag.\n`html\n`\nSee example HTML files in the examples directory.\nWe are working on a webpack build, but due to the advanced JavaScript features used by ReasonDB are having some issues.\nNode Use\nNodeJS currently requires that JavaScript modules be stored in and loaded from .mjs files. ReasonDB is almost 100% isomorphic (i.e. rund the same code on the server as in the client) and the default NodeJS approach breaks isomorphism. Fortunately, there is a great package called esm that effectively overcomes this issue. The esm package is installed as a dependency for ReasonDB. To run a ReasonDB NodeJS application use a command like this:\n`\nnode -r esm index.js\n`","wordCount":163,"type":"Content"},{"name":"JOQULAR Pattern Matching","description":"JavaScript Query Language Representation","path":"/reasondb/tutorials/joqular","text":"JOQULAR provides a simple declaritive way to match JSON objects during query processes. It is based heavily on the MongoDB pattern matching approach but adds support for inline tests and simple extension.\nIn the context of ReasonDB, JOQULAR provides built-in 56 predicates, almost infinite possibilities with inline tests, and and can be extended with new $ predicates in as little as one line of code.\nThe predicates can be broken down into a number of categories including comparisons like $lt, set and array operations like $includes, type tests like $isSSN, text search tests, and logical operators like $and. You can also use inline tests and custom predicates.\nThe basic use of JOQULAR is best shown with an example. The pattern {age:{$gte: 21}} will match {name: \"joe\", age: 22} and {name: \"mary\", age: 21} but not {name: \"mark\", age:19}.\nIn some cases, predicates can take multiple arguments. When this happens, an array shoul dbe used to express the arguments. See $between and $matches for an example.\n&nbsp;\nComparison Operators\n$lt - Mathematical or string less than, e.g. {age: {$lt: 21}}.\n$lte - Mathematical or string less than or equal, e.g. {age: {$lte: 21}}.\n$eq - Primitive value soft equality, e.g. {age: {$eq: 21}} will match both {age: 21} and {age: \"21\"}.\n$eeq - Primitive value strict equality, e.g. {age: {$eq: 21}} will match {age: 21} and not {age: \"21\"}.\n$neq - Primitive value soft inequality.\n$neeq - Primitive value strict inequality.\n$gte - Mathematical or string greater than or equal, e.g. {age: {$gte: 21}}.\n$gt -  Mathematical or string greater than, e.g. {age: {$gt: 21}}.\n$matches - Applies a regular expression match. If an array argument is used, then the first argument is the regular expression and the second is the desired flags. If a string is passed instead of a regular expression, it will be converted into a regular expression, e.g. {name: {$match: [/jo*/,\"i\"]}} will match {name: \"jo\"} and {name: \"Joe\"}.\n&nbsp;\nSet and Array Operators\n$between - Tests if a value is between the provided numeric or string values. To make the test inclusive, pass true as the final value in the array of arguments, e.g. {age: {$between: [5,10]}} and {age: {$between: [5,10,true]}} will both match {age: 6} but only the second will match {age: 5}.\n$outside - Tests if a value is outside the provided numeric or string values, e.g. {age: {$outside: [5,10]}} will match {age: 11}.\n$in - Tests if the value is in the provided array, e.g. {age: {$in: [5,6]}} will match {age: 5} and {age: 6}.\n$nin - Tests if the value is not in the provided array, e.g. {age: {$nin: [5,6]}} will match {age: 4} but not {age: 6}.\n$includes - Assumes the target value is an array and checks to see if it includes the provided value, e.g. {favoriteNumbers: {$includes: 7}} matches {favoriteNumbers: [7,13]}.\n$excludes - Assumes the target value is an array and checks to see if it excludes the provided value, e.g. {favoriteNumbers: {$excludes: 8}} matches {favoriteNumbers: [7,13]}.\n$intersects - Assumes the target value is an array and checks to see if it intersects the provided value, e.g. {favoriteNumbers: {$intersects: [7,14]}} matches {favoriteNumbers: [7,13]}.\n$disjoint - Assumes the target value is an array and checks to see if it is disjoint with the provided value, e.g. {favoriteNumbers: {$disjoint: [3,14]}} matches {favoriteNumbers: [7,13]}.\n&nbsp;\nType Tests\n$typeof -\n$instanceof - Takes either a constructor or a string name of a constructor registered with ReasonDB and ensures the candiate object satisfies instanceof, e.g. {address: {$instanceof: \"Object\"}} will match {name: \"joe\", address: {city: \"Seattle\", state: \"WA\"}}\n$isArray - Examines internals of ReasonDB indexes to determine if the property value is an array.\n$isCreditCard - Uses the Luhn algorithm to verify a number is a credit caard number.\n$isEmail - Uses a regular expression to verify a value is a valid e-mail address.\n$isEven - Returns true if the value is a number and even.\n$isIPAddress - Returns true if the string is a dot delimited IP address.\n$isNaN - Returns true if the value is not a number or is the value NaN.\n$isOdd - Returns true if the value is a number and odd.\n$isSSN - Returns true is the string is a dash delimited US social security number.\n&nbsp;\nText Search Tests\n$echoes - Uses a soundex algorithm, e.g. {name: {$echoes \"jo\"}} will match {name: \"joe\"}.\n$search - Looks to see if the search argument is contained in the property value using both stems and trigrams, e.g. {description: {$search: \"cars\"}} will match {description: \"This car is a 1960 Corvair convertible.\"} because \"car\" is a stem of \"cars\". Leverages full text indexes if available.\n&nbsp;\nLogical Operators\n$and - Puts multiple constraints on a property value, e.g {age: {$and: {$gte: 5, $lte: 10}}}.\n$not - Negates constraints on a property value, e.g {age: {$not: {$and: {$gte: 5, $lte: 10}}}}.\n$or - Puts an or constraint on a property value.\n$xor - Puts an xor constraint on a property value.\n&nbsp;\nInline Tests\nInline tests are invoked with the $ operator. They take a single argument, the value of the property being tested for the current object being considered as a match.\n`javascript\n{name: {$:value => value.length>=2}}\n`\n&nbsp;\nCustom Predicates\nAlmost all built-in predicates are defined the same way you define a predicate. Just create a function with the name you want prefixed by a $. The first argument will always be the value of the property on the object being tested and the second will be the argument to the predicate. If the predicate takes multiple arguments, they will also be present.\nPredicates may be of type async and/or return Promises. If they do, ReasonDB will await their resolution.\nBelow is the definition of $eq.\n`javascript\n\tfunction $eq(a,b) {\n\t\treturn a == b;\n\t}\n`\nTo add predicates to ReasonDB, just pass them in as an keyed object value for the property predicates on the options object when creating a database instance, e.g. new ReasonDB({predicates:{$eq}}).\nPredicates that are not defined this way rely on internals of ReasonDB that may change over time and how to create them is not the subject of further documentation.","wordCount":957,"type":"Content"},{"name":"Extended Type Storage & Indexing","description":"Types of data that can be stored and indexed","path":"/reasondb/tutorials/types","text":"In addition to standard JavaScript primitive data types, ReasonDB can store the values NaN, Infinity, and -Infinity.\nAll properties are indexed and unless an object is marked as atomic, nested objects are replaced with their index key @ during serialization. With the future introduction of schema, indexing will become optional.\nIn some cases, objects can be restored directly from their key value. For example, Dates are not stored directly in the database, they are stored as keys of the form Date@. This conserves RAM and also avoids un-necessry disk access. However, it is generally transparent to the database developer due to the automatic serializing and de-serializing of data by ReasonDB.\nAdditional custom types can be created that leverage the above approach when minimal data is required to define an object, e.g. GeoPoint is currently under development. How to add these types of classes will be documented in a future release.\nReasonDB does not currently support fixed precision or big decimal math; hence, it should not be used for financial applications requiring substative accounting.","wordCount":169,"type":"Content"},{"name":"Cursors","description":"How query cursors work","path":"/reasondb/tutorials/cursors","text":"ReasonDB cursors are very powerful. They are enhanced JavaScript generator iterables that behave much like arrays except their methods are asynchronous, i.e. they support every, find, findIndex, forEach, includes, indexOf, keys, lastIndexOf, map, reduce, reverse, sort, slice, some, and values and can take asynchronous functions as arguments. You can even use array offsets, e.g. myCursor[0], if you first call withMemory().\nAssume the following data is in the database:\n`javascript\n{userId: 1, name: \"joe\"}\n{userId: 2, name: \"mary\"}\n{userId: 3, name: \"jack\"}\n`\nThen you can do the following:\n`javascript\n\tlet cursor = db.match({userId:{$gt: 0}});\n\t// you can use a regular for loop\n\tfor await(const item of cursor) {\n\t\tconsole.log(item);\n\t}\n\t// and reset the cursor to use it again\n\tcursor.reset();\n\tfor await(const item of cursor) {\n\t\tconsole.log(item);\n\t}\n\tcursor.reset();\n\t// you can give the cursor memory so it is index accessable\n\t// Note: this does increase RAM usage\n\tcursor = cursor.withMemory();\n\t//the first time an index is accessed, it must be awaited\n\tconsole.log(await cursor[1]);\n\t// when using arraylike functions, no reset is required if withMemory has been called\n\t// all arraylike functions return Promises\n\t// they also provide the same argument signature as their Array counterparts\n\tcursor.forEach((object,index,generator) => console.log(object,index))\n\t .then(count => console.log(\"count\",count));\n\t// arraylike functions can also be awaited\n\tif(await cursor.some(object => object.name===\"mary\")) {\n\t\tconsole.log(\"some object has the name mary\")\n\t}\n\t// arraylike functions can even call other async functions\n\tif(await cursor.every(async (object) => object.name!=null )) {\n\t\tconsole.log(\"every object has a name\")\n\t}\n\t//since forEach above accesses every array element, await is not needed below\n\tconsole.log(cursor[2]);\n\t//although awaiting will not hurt\n\tconsole.log(await cursor[2]);\n`","wordCount":223,"type":"Content"},{"name":"Database start-up and storage engines","description":"How to start-up a database and use any key value storage engine","path":"/reasondb/tutorials/startup","text":"Starting up a database is simple!\n`javascript\nimport {ReasonDB} from \"../index.js\";\nconst db = ReasonDB.db();\n`\nThe above will create an in memory database since their is no official industry standard persistent store that exists for both the browser and NodeJs. However, using a persistent store is easy:\n`javascript\nimport {ReasonDB} from \"../index.js\";\nconst db = ReasonDB.db({storage:localStorage});\n`\nSo long as your storage engine supports setItem, getItem, removeItem, and clear you will have all the power of ReasonDB. That's right you will even have a graph database and SQL like querying. Internally, ReasonDB maps everything to a key value store for maximum portability.\nSince Redis is a very popular key-value store, an example with Redis is provided below.\n`javascript\nimport {ReasonDB} from \"../index.js\";\nconst\tRedis = require('ioredis');\nclass RedisStorage extends Redis {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t}\n\tasync clear() {\n\t\treturn this.flushdb();\n\t}\n\tasync getItem(key) {\n\t\treturn this.get(key);\n\t}\n\tasync removeItem(key) {\n\t\treturn this.del(key);\n\t}\n\tasync setItem(key,value) {\n\t\treturn this.set(key,value);\n\t}\n}\nconst db = ReasonDB.db({storage:new RedisStorage()});\n`","wordCount":133,"type":"Content"},{"name":"Indexed Key/Value Storage","description":"How to use indexed key/value storage","path":"/reasondb/tutorials/indexedKeyValue","text":"ReasonDB supports key value storage using an asynchronus API similar to the Storage API. The available methods include:\n1) async setItem(key,value) - adds any type of value and associates it with a key.\n2) async putItem(object[,force,options]) - insert the object into the database using the provided options.\n3) async getItem(key) - retrieves the value associated with the key\n4) async* match(pattern) = returns an cursor for all values in the database that match the provided JOQULAR pattern.\n5) async removeItem(key||object||) - removes item associated with the key, or the object based on its unique identifier.\n6) async clear() = Removes all key and values from the database.\nkey(number) is not supported because the asynchronous nature of ReasonDB can't gurantee the sequential order in which keys get returned.\nObjects inserted into the database are optionally indexed so that they can be retrieved using\nExample\n`javascript\n`\n&nbsp;\nsetItem\nAdds any type of value and associates it with a key. If the value is an object and the database option indexAllObjects is truthy, then the object will be added to indexes.\nSyntax\nvar result = await db.setItem(key,value)\nParameters\nkey - A string containing the name of the key you want to create/update.\nvalue - The value you want to give the key you are creating/updating. It can be of any type.\nReturn Value\nThe return value is that of the underlying storage engine, typically undefined.\nExceptions\n&nbsp;\nputItem\nWhen passed an object, will insert the object into the database using the options provided, which default to those used for database start-up. A unique id and version number will be added to the metadata stored in the . property if one does not exist. The id will be accessable through either .[\"#\"] or [\"#\"]. If the object is already under versioning, its version will be incremented unless call options indicate otherwise.\nSyntax\nvar result = await db.putItem(object[,force=false,options=this.options])\nParameters\nobject - An object to insert.\nforce - If truthy, will force a save and index of the object without incrementing the version number and timestamps.\noptions - See database startup.\nReturn Value\nThe return value is that of the underlying storage engine, typically undefined.\nExceptions\n&nbsp;\ngetItem\nWhen passed a key name, will return that key's value.\nSyntax\nvar result = await db.getItem(key)\nParameters\nkey - A string containing the name of the key you want to retrieve the value of.\nReturn Value\nThe value of the item associated with key. If there is no item, returns undefined.\nExceptions\n&nbsp;\nmatch\nWhen passed a JOQULAR pattern, will return a cursor for all matching objects in the database.\nSyntax\nvar result = await db.match(pattern)\nParameters\nkey - A string containing the name of the key you want to retrieve the value of.\nReturn Value\nThe value of the item associated with key. If there is no item, returns undefined.\nExceptions\n&nbsp;\nremoveItem\nWhen passed a key name, will remove that key from the database if it exists. If there is no item associated with the given key, this method will do nothing.\nSyntax\nvar result = await db.removeItem(key||object)\nParameters\nkey - A string containing the name of the key for which you want to remove the value.\nobject - An object with a unique id in the property #.\nReturn Value\nThe return value is that of the underlying storage engine, typically undefined.\nExceptions","wordCount":494,"type":"Content"},{"name":"Graph Storage","description":"How to use graph storage","path":"/reasondb/tutorials/graph","text":"The graph database syntax supported by ReasonDB is similar to that supported by Gun. The basic commands for data insertion and retrieval are: get(path), value(val), graph(object), delete(). There are also more advanced commands put(value), add(value), merge(value), patch(object). See the API documentation for full details. A separate tutorial covers trigger commands that apply to all ReasonDB data models, once(function), on(triggers), off(triggers).\nAdding, Retrieving and Deleting Data\nThe simplest way to think of a graph database is like a file system, each value is stored at a unique path. With ReasonDB, the paths even look like file paths. You can set a value by accessing a path and providing the value to the .value function. You can get a value by simply not providing a value to the .value function.\n`javascript\nawait db.get(\"person/joe/age\").value(27);\nconst joeage = db.get(\"/person/joe/age\").value(); // joeage will be 27\n`\nTo delete data, just access the path and call .delete().\n`javascript\nawait db.get(\"person/joe/age\").delete();\nconst joeage = db.get(\"person/joe/age\").value(); // joeage will be undefined\n`\nYou can also put values at multiple levels in the graph, not just leaves, e.g.\n`javascript\nawait db.get(\"a\").value(\"Value at a\");\nawait db.get(\"a/b\").value(\"Value at b\");\n`\nPath Expressions\nThe paths support an expression language that can include typical comparison operators like `>,>=, value.length>2.\n`javacript\nconst shortNamedAges = db.get(\"person/(name) => name.length  console.log(await age.value()));\n`\nThe path expression above is testing the path component, if you want to test the value, then use a colon. The code for each of the below will return undefined unless the value stored on a/b is \"Value at b\".\n`javascript\nconst bvalue = await db.get(\"a/b:(value) => value === \"Value at b\").value();\n`\n`javascript\nconst bvalue = await db.get(\"a/b:$eq(\"Value at b)\").value();\n`\nAutomatically Graphing Objects\nUnless a graph data model parrallels the business domain being modeled, many people find the mapping of objects to graphs tedious and subject to error because there are many ways to choose path names. To help overcome this obstacle, ReasonDB provides the .putItem command. Just give it a JSON object and the graph will be created automatically.\n`javascript\nawait db.putItem({name:\"joe\",age:27});\nawait db.putItem({name:\"mary\",age:27});\n`\nWill first add unique ids to the objects, e.g. {name:\"joe\",age:27,\"#\":\"Object@a67fhtkquiryxst\"} and {name:\"mary\",age:27,\"#\":\"Object@a68fhtsquirxsy\"}. Then the following paths will be createded:\n`\nObject/name/\"joe\"/Object@a67fhtkquiryxst\nObject/name/\"mary\"/Object@a68fhtsquirxsy\nObject/age/27/Object@a67fhtkquiryxst\nObject/age/27/Object@a68fhtsquirxsy\n`\nNote above that the path actually has \"joe\" and \"mary\" as embedded strings. This is an internal optimization for ReasonDB indexes.\nYou can now query the graph for all 27 year olds as follows:\n`javascript\nconst people = db.get(\"Object/age/==27/*\");\npeople.forEach(person => console.log(await person.value()));\n`\nWhich will print:\n`javacript\n{\"name\":\"joe\",\"age:27\",\"#\":\"Object@a67fhtkquiryxst\"}\n{\"name\":\"mary\",\"age:27\",\"#\":\"Object@a68fhtsquirxsy\"}\n`\nThe .value function is \"smart\" and knows that if a value represents a unique id, it should return the object, not the id.\nYou can even use custom classes:\n`javascript\nclass Person {\n\tconstructor(config) {\n\t\tObject.assign(this,config);\n\t}\n}\nconst p1 = new Person({\"name\":\"joe\",\"age:27\"}),\n\tp2 = new Person({\"name\":\"mary\",\"age:27\"});\ndb.putItem(p1);\ndb.putItem(p2);\n`\nwill result in the following paths being created:\n`\nPerson/name/\"joe\"/Person@a67fhtkquiryxst\nPerson/name/\"mary\"/Person@a68fhtsquirxsy\nPerson/age/27/Person@a67fhtkquiryxst\nPerson/age/27/Person@a68fhtsquirxsy\n`","wordCount":412,"type":"Content"},{"name":"SQL Like Statements","description":"How to use SQL like statements","path":"/reasondb/tutorials/SQLlike","text":"","wordCount":0,"type":"Content"},{"name":"Full text indexing","description":"Using stem and trigram based full text indexing","path":"/reasondb/tutorials/fulltext","text":"","wordCount":0,"type":"Content"},{"name":"Conflict Resolution","description":"How conflict resolution works","path":"/reasondb/tutorials/conflictresolution","text":"","wordCount":0,"type":"Content"},{"name":"API Documentation","description":"APIs","path":"/reasondb/api","text":"","wordCount":0,"type":"TOC"},{"name":"API Introduction","description":"how to read the API documentation","path":"/reasondb/api/introduction","text":"","wordCount":0,"type":"Content"},{"name":"Helpful Links","description":"Additional reading, links to other database APIs","path":"/reasondb/links","text":"Links\nTBD","wordCount":1,"type":"Content"},{"name":"FAQs","description":"Frequently asked questions are covered here","path":"/reasondb/faq","text":"This content is refreshed as new features and functions are introduced, or existing functions evolve.  Check back often!","wordCount":18,"type":"Content"},{"name":"Our Roadmap","description":"Aligning our development plans with our stakeholders","path":"/reasondb/roadmap","text":"","wordCount":0,"type":"Content"}]